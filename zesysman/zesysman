#!/usr/bin/env python3
# Copyright (C) 2020 Intel Corporation
# SPDX-License-Identifier: MIT

import os
import re
import signal
import sys
import time

from zesys import *
from zesys.output import *
from zesys.types import *
from zesys.zes_wrap import *

pr = logger.pr

#
# API STUBS for testing
#

if util.developer_mode() == "STUB_API":
    stubs = stub.api()
elif util.developer_mode() == "STUB_TOPO":
    stubs = stub.topo()
else:
    stubs = {}

for f in stubs:
    exec(stub.replacement_map_to_call_dict(f, "stubs"))

def driverUUIDs(count, drivers):
    uuids = []
    for i in range(count):
        driver = drivers[i]
        driver_props = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES)
        zeCall(zeDriverGetProperties(driver, driver_props))
        uuid_string = uuid_string_t()
        driver_uuid_to_string(driver_props.uuid, uuid_string)
        uuids.append(str(uuid_string.id))
    return uuids

def listDrivers(count, drivers):
    Node = otree.NodeClass
    savedPr = otree.pr
    otree.pr = pr.err
    topNode = Node(None, "Available Drivers", None)
    for i in range(count):
        driver = drivers[i]
        driver_props = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES)
        zeCall(zeDriverGetProperties(driver, driver_props))
        uuid_string = uuid_string_t()
        driver_uuid_to_string(driver_props.uuid, uuid_string)
        drvNode = Node(topNode, "Driver", None, ("Index", i), ("UUID", output.uuid(uuid_string.id)),
                       index=True)
        api_version = zeCall(zeDriverGetApiVersion(driver))
        Node(drvNode, "API version", versionString(api_version))
        Node(drvNode, "Driver version", driver_props.driverVersion)
        ipcProps = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES)
        zeCall(zeDriverGetIpcProperties(driver, ipcProps))
        Node(drvNode, "IPC passing", ipcPropertiesString(ipcProps.flags))

    topNode.outputStart()
    topNode.outputTree()
    topNode.outputFinish()
    otree.pr = savedPr

def listDriversAndFail(count, drivers):
    listDrivers(count, drivers)
    pr.fail("Use --driver to specify a valid driver")

def listDevices(driverIndices, deviceCounts, deviceLists):
    Node = otree.NodeClass
    savedPr = otree.pr
    otree.pr = pr.err
    topNode = Node(None, "Available Devices", None)
    for driver, count, devices in zip(driverIndices, deviceCounts, deviceLists):
        for i in range(count):
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            if len(driverIndices) > 1:
                devNode = Node(topNode, "Device", None, ("Index", str(driver) + "." + str(i)),
                               ("UUID", output.uuid(uuid_string.id)), index=True)
            else:
                devNode = Node(topNode, "Device", None, ("Index", i), ("UUID",
                               output.uuid(uuid_string.id)), index=True)
            Node(devNode, "Type", deviceTypeString(device_properties.type))
            Node(devNode, "Name", device_properties.name)
            Node(devNode, "VendorId", hex(device_properties.vendorId))
            Node(devNode, "DeviceId", hex(device_properties.deviceId))

    topNode.outputStart()
    topNode.outputTree()
    topNode.outputFinish()
    otree.pr = savedPr

def listDevicesAndFail(driverIndices, deviceCounts, deviceLists):
    listDevices(driverIndices, deviceCounts, deviceLists)
    pr.fail("Use --device to specify a set of valid devices")

def uniquify_index(indices, info):
    newIndices, newInfo = [], []
    for i,o in zip(indices, info):
        if i not in newIndices:
            newIndices.append(i)
            newInfo.append(o)
    return newIndices, newInfo

def getDrivers(driverSelection):
    driverCount = uint32_ptr()
    zeCall(zeDriverGet(driverCount.cast(), None))
    numDrivers = driverCount.value()
    if numDrivers < 1:
        pr.fail("No compatible drivers found")

    drivers = ze_driver_handle_array(numDrivers)
    zeCall(zeDriverGet(driverCount.cast(), drivers.cast()))

    if driverSelection:
        indices = []
        uuids = driverUUIDs(numDrivers, drivers)
        for selection in driverSelection:
            sel = selection.lower()

            if sel == "list":
                listDrivers(numDrivers, drivers)
                exit(0)

            try:
                i = int(sel)
                if i < 0 or i >= numDrivers:
                    raise
                indices.append(i)
            except:
                if sel.startswith("uuid:") and len(sel) > 5:
                    sel = sel[5:]
                    selection = selection[5:]
                if sel in uuids:
                    indices.append(uuids.index(sel))
                else:
                    found = False
                    sel_re = re.compile(selection, re.IGNORECASE)
                    for i,uuid in util.indexed(uuids):
                        if sel_re.search(uuid):
                            found = True
                            indices.append(i)
                    if not found:
                        pr.err("Error: Unknown driver index/UUID regexp:", selection)
                        listDriversAndFail(numDrivers, drivers)

        # uniquify:
        indices = list(set(indices))
        indices.sort()
    else:
        indices = range(numDrivers)

    return indices, drivers

def getDeviceDetails(deviceCounts, deviceLists):
    uuids = []
    names = []
    for count, devices in zip(deviceCounts, deviceLists):
        for i in range(count):
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            uuids.append(str(uuid_string.id))
            names.append(device_properties.name)
    return uuids, names

def firstMatch(sel, *places):
    for place in places:
        if sel in place:
            return place.index(sel)
    return None

def getDevices(driverIndices, drivers, deviceSelection):
    deviceFound = False
    deviceCounts = []
    deviceLists = []

    for _,driver in zip(driverIndices, drivers):
        deviceCount = uint32_ptr()
        zeCall(zeDeviceGet(driver, deviceCount.cast(), None))

        if deviceCount.value() > 0:
            deviceFound = True
            driverDevices = ze_device_handle_array(deviceCount.value())
            zeCall(zeDeviceGet(driver, deviceCount.cast(), driverDevices.cast()))
        else:
            driverDevices = None

        deviceCounts.append(deviceCount.value())
        deviceLists.append(driverDevices)

    if not deviceFound:
        pr.fail("No devices found")

    allUUIDs, allNames = getDeviceDetails(deviceCounts, deviceLists)
    allIndices = [ (r,d) for r,c in util.indexed(deviceCounts) for d in range(c) ]

    expandedIDs = [ str(driverIndices[r]) + "." + str(d) for r,d in allIndices ]

    if len(driverIndices) > 1:
        deviceIDs = expandedIDs
    else:
        deviceIDs = [ str(d) for r, d in allIndices ]

    if deviceSelection:
        indices = []
        deviceUUIDs = []
        for selection in deviceSelection:
            sel = selection.lower()

            if sel == "list":
                listDevices(driverIndices, deviceCounts, deviceLists)
                exit(0)

            if sel.startswith("name:") and len(sel) > 5:
                selection = selection[5:]
                i = firstMatch(selection, allNames)

                if i is not None:
                    indices.append(allIndices[i])
                    deviceUUIDs.append(allUUIDs[i])
                else:
                    found = False
                    sel_re = re.compile(selection)
                    for i,name in util.indexed(allNames):
                        if sel_re.search(name):
                            found = True
                            indices.append(allIndices[i])
                            deviceUUIDs.append(allUUIDs[i])
                    if not found:
                        pr.err("Error: Unknown name regexp:", selection)
                        listDevicesAndFail(driverIndices, deviceCounts, deviceLists)
                continue

            if sel.startswith("uuid:") and len(sel) > 5:
                sel = sel[5:]
                selection = selection[5:]
                i = firstMatch(sel, allUUIDs)

                if i is not None:
                    indices.append(allIndices[i])
                    deviceUUIDs.append(allUUIDs[i])
                else:
                    found = False
                    sel_re = re.compile(selection, re.IGNORECASE)
                    for i,uuid in util.indexed(allUUIDs):
                        if sel_re.search(uuid):
                            found = True
                            indices.append(allIndices[i])
                            deviceUUIDs.append(allUUIDs[i])
                    if not found:
                        pr.err("Error: Unknown UUID regexp:", selection)
                        listDevicesAndFail(driverIndices, deviceCounts, deviceLists)
                continue

            i = firstMatch(selection, allNames)
            if i is None:
                i = firstMatch(sel, allUUIDs, deviceIDs, expandedIDs)

            if i is not None:
                indices.append(allIndices[i])
                deviceUUIDs.append(allUUIDs[i])
            else:
                found = False
                sel_re = re.compile(selection, re.IGNORECASE)
                for i,name in util.indexed(allNames):
                    if sel_re.search(name):
                        found = True
                        indices.append(allIndices[i])
                        deviceUUIDs.append(allUUIDs[i])
                if found:
                    continue
                for i,uuid in util.indexed(allUUIDs):
                    if sel_re.search(uuid):
                        found = True
                        indices.append(allIndices[i])
                        deviceUUIDs.append(allUUIDs[i])
                if not found:
                    pr.err("Error: Unknown device index/name/UUID regexp:", selection)
                    listDevicesAndFail(driverIndices, deviceCounts, deviceLists)

        indices, deviceUUIDs = uniquify_index(indices, deviceUUIDs)

        if len(driverIndices) > 1:
            deviceIDs = [ str(driverIndices[r]) + "." + str(d) for r, d in indices ]
        else:
            deviceIDs = [ str(d) for r, d in indices ]
    else:
        indices = allIndices
        deviceUUIDs = allUUIDs

    sysmanDevices = [deviceLists[r][d] for r,d in indices]

    return deviceIDs, deviceUUIDs, sysmanDevices

def findTestSuite(diagCount, diags, name):
    diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
    match = None
    for i in range(diagCount):
        diag = diags[i]
        zeCall(zesDiagnosticsGetProperties(diag, diagProps))
        # TODO: should we allow regexp matching?
        if name == diagProps.name:
            if match is None:
                match = i
            else:
                logger.pr.err("ERROR:", name, "does not specify one test suite exactly, use index form")
                raise ValueError(name)

    if match is None:
        logger.pr.err("ERROR:", name, "does not match any test suite name")
        raise ValueError(name)

    return match

def parseTestSuite(diagCount, diags, opts):
    opt_string = " ".join(opts)
    suite = opts.pop(0)
    try:
        i = int(suite, 0)
        assert(i < diagCount)
    except:
        i = findTestSuite(diagCount, diags, suite)

    diag = diags[i]

    if opts:
        try:
            first = int(opts.pop(0), 0)
            if opts:
                last = int(opts.pop(0), 0)
            else:
                last = first
            assert(not opts)
        except:
            logger.pr.err("ERROR:", opt_string, "should be of form SUITE [N [N]]")
            raise ValueError(opts)
        else:
            diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
            zeCall(zesDiagnosticsGetProperties(diag, diagProps))
            if diagProps.haveTests:
                firstFound, lastFound = False, False
                testCount = uint32_ptr()
                try:
                    zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), None))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                else:
                    tests = zes_diag_test_array(testCount.value())
                    zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), tests.cast()))
                    for t in range(testCount.value()):
                        test = tests[t]
                        if test.index == first:
                            firstFound = True
                        if test.index == last:
                            lastFound = True
                if not firstFound and first != ZES_DIAG_FIRST_TEST_INDEX:
                    logger.pr.err("WARNING:", first, "not found in test suite")
                if not lastFound and last != first and ((last & 0xffffffff) !=
                                                        (ZES_DIAG_LAST_TEST_INDEX & 0xffffffff)):
                    logger.pr.err("WARNING:", last, "not found in test suite")
            else:
                logger.pr.err("WARNING: Test suite has no individual subtests")
    else:
        first, last = ZES_DIAG_FIRST_TEST_INDEX, ZES_DIAG_LAST_TEST_INDEX

    return diag, first, last

def sigintHandler(sigNum, frame):
    state.earlyExit.set()
    state.maxIterations = 0

def delay(pollInterval):
    return not state.earlyExit.wait(pollInterval)

def unitsMHz(node):
    if type(node.text) == str or node.text < 0:
        node.text = "?"
        node.replaceUnits("MHz")
    elif node.text < 1000:
        node.text = "%.1f" % node.text
        node.replaceUnits("MHz")
    else:
        node.text = "%.2f" % (node.text / 1000)
        node.replaceUnits("GHz")

def units_mW(node):
    if type(node.text) == str or node.text < 0:
        node.text = "?"
        node.replaceUnits("W")
    elif node.text == 0:
        node.text = "%.1f" % node.text
        node.replaceUnits("W")
    elif node.text < 1000:
        node.text = "%.1f" % node.text
        node.replaceUnits("mW")
    elif node.text < 1000000:
        node.text = "%.2f" % (node.text / 1000)
        node.replaceUnits("W")
    else:
        node.text = "%.2f" % (node.text / 1000000)
        node.replaceUnits("kW")

def units_ms(node):
    if type(node.text) == str or node.text < 0:
        node.text = "?"
        node.replaceUnits("s")
    elif node.text == 0:
        node.text = "%.1f" % node.text
        node.replaceUnits("s")
    elif node.text < 1000:
        node.text = "%.1f" % node.text
        node.replaceUnits("ms")
    else:
        node.text = "%.2f" % (node.text / 1000)
        node.replaceUnits("s")

def units_us(node):
    if type(node.text) == str or node.text < 0.0:
        node.text = "?"
        node.replaceUnits("ms")
    elif node.text == 0.0:
        node.text = "%.1f" % node.text
        node.replaceUnits("ms")
    elif node.text < 1000.0:
        node.text = "%.1f" % node.text
        node.replaceUnits("us")
    elif node.text < 1000000.0:
        node.text = "%.2f" % (node.text / 1000)
        node.replaceUnits("ms")
    else:
        node.text = "%.2f" % (node.text / 1000000)
        node.replaceUnits("s")

def thresh_mJ(node):
    if type(node.text) == str or node.text < 0.0:
        node.text = "?"
        node.replaceUnits("J")
    elif node.text == 0.0:
        node.text = "unspecified"
        node.replaceUnits("J")
    elif node.text < 0.001:
        node.text = "%.1f" % (node.text * 1000000)
        node.replaceUnits("uJ")
    elif node.text < 1.0:
        node.text = "%.2f" % (node.text * 1000)
        node.replaceUnits("mJ")
    elif node.text < 1000.0:
        node.text = "%.2f" % (node.text)
        node.replaceUnits("J")
    elif node.text < 1000000.0:
        node.text = "%.2f" % (node.text / 1000)
        node.replaceUnits("kJ")
    else:
        node.text = "%.2f" % (node.text / 1000000)
        node.replaceUnits("MJ")

def unitsV(node):
    if type(node.text) == str or node.text < 0.0:
        node.text = "?"
        node.replaceUnits("V")
    elif node.text == 0.0:
        node.text = "%.1f" % node.text
        node.replaceUnits("V")
    elif node.text < 0.001:
        node.text = "%.1f" % (node.text * 1000000)
        node.replaceUnits("uV")
    elif node.text < 1.0:
        node.text = "%.1f" % (node.text * 1000)
        node.replaceUnits("mV")
    elif node.text < 1000.0:
        node.text = "%.1f" % (node.text)
        node.replaceUnits("V")
    elif node.text < 1000000.0:
        node.text = "%.2f" % (node.text / 1000)
        node.replaceUnits("kV")
    else:
        node.text = "%.2f" % (node.text / 1000000)
        node.replaceUnits("MV")

def units_mA(node):
    if type(node.text) == str or node.text < 0.0:
        node.text = "?"
        node.replaceUnits("A")
    elif node.text == 0:
        node.text = "%.1f" % node.text
        node.replaceUnits("A")
    elif node.text < 1.0:
        node.text = "%.1f" % (node.text * 1000)
        node.replaceUnits("uA")
    elif node.text < 1000:
        node.text = "%.2f" % node.text
        node.replaceUnits("mA")
    else:
        node.text = "%.3f" % (node.text / 1000)
        node.replaceUnits("A")

# TODO: Should kB be 1000 or 1024 (kiB), etc.?
def unitsB(node):
    if type(node.text) == str or node.text < 0:
        node.text = "?"
        node.replaceUnits("B")
    elif node.text < 1000:
        node.replaceUnits("B")
    elif node.text < 1000000:
        node.text = "%.1f" % (node.text / 1000)
        node.replaceUnits("kB")
    elif node.text < 1000000000:
        node.text = "%.1f" % (node.text / 1000000)
        node.replaceUnits("MB")
    elif node.text < 1000000000000:
        node.text = "%.2f" % (node.text / 1000000000)
        node.replaceUnits("GB")
    else:
        node.text = "%.2f" % (node.text / 1000000000000)
        node.replaceUnits("TB")

# TODO: Should kB be 1000 or 1024 (kiB), etc.?
def unitsBps(node):
    if type(node.text) == str or node.text < 0:
        node.text = "?"
        node.replaceUnits("B/s")
    elif node.text < 1000:
        node.replaceUnits("B/s")
    elif node.text < 1000000:
        node.text = "%.1f" % (node.text / 1000)
        node.replaceUnits("kB/s")
    elif node.text < 1000000000:
        node.text = "%.1f" % (node.text / 1000000)
        node.replaceUnits("MB/s")
    elif node.text < 1000000000000:
        node.text = "%.2f" % (node.text / 1000000000)
        node.replaceUnits("GB/s")
    else:
        node.text = "%.2f" % (node.text / 1000000000000)
        node.replaceUnits("TB/s")

# TODO: Should kb be 1000 or 1024 (kib), etc.?
def units_bps(node):
    if type(node.text) == str or node.text < 0:
        node.text = "?"
        node.replaceUnits("bps")
    elif node.text < 1000:
        node.replaceUnits("bps")
    elif node.text < 1000000:
        node.text = "%.1f" % (node.text / 1000)
        node.replaceUnits("kbps")
    elif node.text < 1000000000:
        node.text = "%.1f" % (node.text / 1000000)
        node.replaceUnits("Mbps")
    elif node.text < 1000000000000:
        node.text = "%.2f" % (node.text / 1000000000)
        node.replaceUnits("Gbps")
    else:
        node.text = "%.2f" % (node.text / 1000000000000)
        node.replaceUnits("Tbps")

#
# Main program
#
def main():
    args = arg.parse()

    if state.maxIterations > 1:
        signal.signal(signal.SIGINT, sigintHandler)

    driverIndices, drivers = getDrivers(args.driver)

    deviceIDs, deviceUUIDs, devices = getDevices(driverIndices, drivers, args.device)

    generatingDeviceReport = False
    dryRunMessage = "Action suppressed: --dry-run specified"

    if args.show_all:
        args.show_temp, args.show_power, args.show_freq, args.show_util = True, True, True, True
        args.show_mem, args.show_pci, args.show_fabric_ports = True, True, True
        args.show_standby, args.show_errors = True, True

    if (args.show_device or args.show_processes or args.show_scheduler or args.show_temp or
        args.show_power or args.show_freq or args.show_util or args.show_mem or args.show_pci or
        args.show_fabric_ports or args.show_standby or args.show_errors or args.show_diag or
        args.show_fans or args.show_firmware or args.show_oc or args.show_leds or args.show_perf or
        args.show_psu):

        generatingDeviceReport = True

        if not args.show_inventory:
            args.show_telemetry = True

    elif args.show_inventory or args.show_telemetry:

        args.show_temp, args.show_power, args.show_freq, args.show_util = True, True, True, True
        args.show_mem, args.show_pci, args.show_fabric_ports = True, True, True
        args.show_standby, args.show_errors = True, True

        generatingDeviceReport = True

    if args.show_topo:
        generatingDeviceReport = True

    if not generatingDeviceReport:
        otree.setNullNodeClass()

    Node = otree.NodeClass

    pollDelayRequired = False
    telemetryClosures = []

    if args.reset:
        if len(devices) != 1:
            pr.fail("Cannot reset more than one GPU at a time")

        deviceName = "%s [%s]" % (deviceIDs[0], output.uuid(deviceUUIDs[0]))

        if args.dry_run:
            args.yes = True

        if not args.yes and not args.dry_run:
            answer = input("Do you really want to reset device " + deviceName + "? ")
            args.yes = answer.lower() in ("y", "yes")

        if args.yes:
            pr("Resetting device %s%s" % (deviceName, [""," (forced)"][args.force]))
            if args.dry_run:
                pr(dryRunMessage)
            else:
                zeCall(zesDeviceReset(devices[0], args.force))
        else:
            pr("NOT resetting device")

        sys.exit(0)

    if args.run_diag:
        if len(devices) != 1:
            pr.fail("Cannot test more than one GPU at a time")

        diagCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumDiagnosticTestSuites(devices[0], diagCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            diags = zes_diag_handle_array(diagCount.value())
            zeCall(zesDeviceEnumDiagnosticTestSuites(devices[0], diagCount.cast(), diags.cast()))

        suite, first, last = parseTestSuite(diagCount.value(), diags, args.run_diag)

        deviceName = "%s [%s]" % (deviceIDs[0], output.uuid(deviceUUIDs[0]))
        pr("Device diagnostics:", deviceName)

        if args.dry_run:
            pr(dryRunMessage)
        else:
            result = zeCall(zesDiagnosticsRunTests(suite, first, last))
            pr("Diagnostic test result:", diagResultString(result))

        sys.exit(result)

    if args.wait_events is not None:
        if len(driverIndices) != 1:
            pr.err("ERROR: can only wait on events from one driver at a time")
            sys.exit(1)

        allEvents = (ZES_EVENT_TYPE_FLAG_DEVICE_DETACH | ZES_EVENT_TYPE_FLAG_DEVICE_ATTACH |
                     ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_ENTER |
                     ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_EXIT | ZES_EVENT_TYPE_FLAG_FREQ_THROTTLED |
                     ZES_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED | ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL |
                     ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 | ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 |
                     ZES_EVENT_TYPE_FLAG_MEM_HEALTH | ZES_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH |
                     ZES_EVENT_TYPE_FLAG_PCI_LINK_HEALTH | ZES_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS |
                     ZES_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS |
                     ZES_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED)

        if len(args.wait_events) > 1:
            selectedEvents = int(args.wait_events[1],0) & allEvents
        else:
            selectedEvents = allEvents

        pr("Waiting on device event mask %x" % selectedEvents)
        if args.dry_run:
            pr(dryRunMessage)
            sys.exit(0)

        for device in devices:
            try:
                zeCall(zesDeviceEventRegister(device, selectedEvents))
            except NotImplementedError:
                pass
            except ValueError:
                logger.reportZeException()

        driver = drivers[0]
        if len(args.wait_events) > 0:
            timeout = int(args.wait_events[0],0) & 0xffffffff
        else:
            timeout = 1000
        count = len(devices)
        phDevices = ze_device_handle_array(count)
        for i, device in util.indexed(devices):
            phDevices[i] = device
        pEvents = zes_event_type_flags_array(count)

        try:
            numEvents = zeCall(zesDriverEventListen(driver, timeout, count, phDevices.cast(), pEvents.cast()))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            if numEvents:
                pr(numEvents, "device(s) reported events:")
                for i in range(count):
                    events = eventsString(pEvents[i])
                    pr("   ", deviceIDs[i], ":", deviceUUIDs[i], events)
            else:
                pr("No events reported")

        for device in devices:
            try:
                zeCall(zesDeviceEventRegister(device, 0))
            except NotImplementedError:
                pass
            except ValueError:
                logger.reportZeException()

        sys.exit(0)

    if args.show_topo:
        if args.dry_run:
            pr("Topology Report", dryRunMessage)
            sys.exit(0)

        fabric = []
        fabricMap = {}
        fabricAttach = {}
        fabricIds = []

        try:
            for devID, device in zip(deviceIDs, devices):
                portCount = uint32_ptr()
                zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), None))
                ports = zes_fabric_port_handle_array(portCount.value())
                zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), ports.cast()))

                for i in range(portCount.value()):
                    port = ports[i]
                    pp = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES)
                    zeCall(zesFabricPortGetProperties(port, pp))
                    src = (pp.portId.fabricId, pp.portId.attachId, pp.portId.portNumber)
                    ps = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE)
                    zeCall(zesFabricPortGetState(port, ps))
                    if ps.status not in [ZES_FABRIC_PORT_STATUS_HEALTHY, ZES_FABRIC_PORT_STATUS_DEGRADED]:
                        continue
                    dst = (ps.remotePortId.fabricId, ps.remotePortId.attachId, ps.remotePortId.portNumber)
                    fabric.append((src,dst))
                    if src[0] not in fabricIds:
                        fabricIds.append(src[0])
                    sds = fabricAttach.setdefault(src[0], set())
                    sds.add(src[1])
                    sdd = fabricAttach.setdefault(dst[0], set())
                    sdd.add(dst[1])
                    if devID not in fabricMap.setdefault(src[0], [devID]):
                        fabricMap[src[0]].append(devID)
                        pr.err("Fabric ID", src[0], "maps to multiple devices:", ",".join(fabricMap[src[0]]))
        except NotImplementedError:
            pr("Not supported by current driver")
        except ValueError:
            logger.reportZeException()

        if args.show_topo == "matrix":
            matrix = [["-"] * len(deviceIDs) for _ in deviceIDs]
            for d in range(len(deviceIDs)):
                matrix[d][d] = "X"
            for connection in fabric:
                for src in fabricMap.get(connection[0][0],[]):
                    s = deviceIDs.index(src)
                    for dest in fabricMap.get(connection[1][0],[]):
                        d = deviceIDs.index(dest)
                        matrix[s][d] = "x"
            if args.uuid_index:
                header_column = ["", " "*36]
            else:
                header_column = [""]
            pr("\t".join(header_column + list(map(str, deviceIDs))))
            for src in (deviceIDs):
                s = deviceIDs.index(src)
                if args.uuid_index:
                    header_column = [src, deviceUUIDs[s]]
                else:
                    header_column = [src]
                pr("\t".join(header_column + matrix[s]))

        if args.show_topo == "graph":
            pr("graph fabric {")
            for f in fabricIds:
                m = fabricMap.get(f,[])
                if args.uuid_index:
                    m = [d + "\\n" + deviceUUIDs[deviceIDs.index(d)] for d in m]
                m = ["Device " + d for d in m]
                pr('    "d{}" [label="{}" shape=box style=filled fillcolor="#cccccc"]'.format(f,"\\n".join(m)))
            for f,m in fabricAttach.items():
                for sd in m:
                    pr('    "sd{},{}" [label="{}" style=filled fillcolor="#eeeeee"]'.format(f,sd,sd))
                    pr('    "d{}" -- "sd{},{}" [color="#888888"]'.format(f,f,sd))
            shown = set()
            for (f,s,p),(rf,rs,rp) in fabric:
                if (f,s,p) not in shown:
                    shown.add((f,s,p))
                    shown.add((rf,rs,rp))
                    pr('    "sd{},{}" -- "sd{},{}"'.format(f,s,rf,rs))
            pr("}")

        if args.show_topo == "info":
            topNode = Node(None, "Devices", None, discard=["list"])
            for devID, devUUID in zip(deviceIDs, deviceUUIDs):
                for fabricId in fabricIds:
                    if devID in fabricMap[fabricId]:
                        devNode = Node(topNode, "Device", None, ("Index", devID),
                                       ("UUID", output.uuid(devUUID)), index=True)
                        Node(devNode, "FabricID", hex(fabricId))
                        sdsNode = Node(devNode, "AttachPoints", None)
                        sds = list(fabricAttach[fabricId])
                        sds.sort()
                        for sd in sds:
                            sdNode = Node(sdsNode, "AttachPoint", None, ("Index", sd))
                            for (f,s,p),(rf,rs,rp) in fabric:
                                if (f,s) == (fabricId,sd):
                                    portNode = Node(sdNode, "Port", None, ("Index", p), join=".")
                                    Node(portNode, "RemoteFabricId", hex(rf), join=".")
                                    Node(portNode, "RemoteAttachId", rs, join=".")
                                    Node(portNode, "RemotePortNumber", rp, join=".")
            topNode.outputStart()
            topNode.outputTree()
            topNode.outputFinish()

        sys.exit(0)

    if args.ascii:
        degC = "degC"
    else:
        degC = "°C"

    if state.maxIterations > 1:
        topNode = Node.IterationNode(None, "Iteration", None)
        devicesNode = Node(topNode, "Devices", None, discard=["list"])
    else:
        devicesNode = Node(None, "Devices", None, discard=["list"])
        topNode = devicesNode

    for devID, devUUID, device in zip(deviceIDs, deviceUUIDs, devices):
        devNode = Node(devicesNode, "Device", None, ("Index", devID), ("UUID", output.uuid(devUUID)),
                       index=True)
        if args.show_device:
            coreProps = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, coreProps))
            Node(devNode, "Name", coreProps.name)
            Node(devNode, "Type", deviceTypeString(coreProps.type))
            Node(devNode, "VendorId", hex(coreProps.vendorId))
            Node(devNode, "DeviceId", hex(coreProps.deviceId))
            if args.show_inventory:
                try:
                    props = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES)
                    zeCall(zesDeviceGetProperties(device, props))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                else:
                    Node(devNode, "NumSubdevices", props.numSubdevices)
                    Node(devNode, "serialNumber", props.serialNumber)
                    Node(devNode, "boardNumber", props.boardNumber)
                    Node(devNode, "brandName", props.brandName)
                    Node(devNode, "modelName", props.modelName)
                    Node(devNode, "vendorName", props.vendorName)
                    Node(devNode, "driverVersion", props.driverVersion)
                    if args.verbose:
                        Node(devNode, "coreClockRate", props.core.coreClockRate, ("Units", "MHz"), setFn=unitsMHz)
                        Node(devNode, "maxMemAllocSize", props.core.maxMemAllocSize)
                        Node(devNode, "maxHardwareContexts", props.core.maxHardwareContexts)
                        Node(devNode, "timestampValidBits", props.core.timestampValidBits)
                        Node(devNode, "kernelTimestampValidBits", props.core.kernelTimestampValidBits)
                        Node(devNode, "maxCommandQueuePriority", props.core.maxCommandQueuePriority)
                        Node(devNode, "numThreadsPerEU", props.core.numThreadsPerEU)
                        Node(devNode, "physicalEUSimdWidth", props.core.physicalEUSimdWidth)
                        Node(devNode, "numEUsPerSubslice", props.core.numEUsPerSubslice)
                        Node(devNode, "numSubslicesPerSlice", props.core.numSubslicesPerSlice)
                        Node(devNode, "numSlices", props.core.numSlices)
                        Node(devNode, "timerResolution", props.core.timerResolution)

            if args.show_telemetry:
                nodes = []
                nodes.append(Node(devNode, "ResetReasons", "?"))
                nodes.append(Node(devNode, "RepairStatus", "?"))

                def deviceTelemetry(device=device, nodes=nodes):
                    state = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_STATE)
                    try:
                        zeCall(zesDeviceGetState(device, state))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        nodes[0].setText(resetReasonsString(state.reset))
                        nodes[1].setText(repairStatusString(state.repaired))

                telemetryClosures.append(deviceTelemetry)

        tempCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumTemperatureSensors(device,tempCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            temperatures = zes_temp_handle_array(tempCount.value())
            zeCall(zesDeviceEnumTemperatureSensors(device,tempCount.cast(), temperatures.cast()))

        if args.enable_critical_temp:
            t, = args.enable_critical_temp
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.enableCritical = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_critical_temp:
            t, = args.disable_critical_temp
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.enableCritical = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t1_low_to_high:
            t, = args.enable_t1_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableLowToHigh = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t1_low_to_high:
            t, = args.disable_t1_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableLowToHigh = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t1_high_to_low:
            t, = args.enable_t1_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableHighToLow = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t1_high_to_low:
            t, = args.disable_t1_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableHighToLow = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.set_t1_threshold:
            t,v = args.set_t1_threshold
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.threshold = v
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t2_low_to_high:
            t, = args.enable_t2_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableLowToHigh = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t2_low_to_high:
            t, = args.disable_t2_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableLowToHigh = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t2_high_to_low:
            t, = args.enable_t2_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableHighToLow = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t2_high_to_low:
            t, = args.disable_t2_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableHighToLow = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.set_t2_threshold:
            t,v = args.set_t2_threshold
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.threshold = v
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")

        if args.show_temp:
            tempTop = Node(devNode, "TemperatureSensors", None)

            for i in range(tempCount.value()):
                temp = temperatures[i]
                tempProps = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_PROPERTIES)
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetProperties(temp, tempProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    logger.reportZeException()
                    continue
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                tempType = tempTypeString(tempProps.type)
                if tempProps.onSubdevice:
                    tempNode = Node(tempTop, "TemperatureSensor", None, ("Index", i), ("Name", tempType),
                                    ("SubdeviceId", tempProps.subdeviceId), heading="Temp")
                else:
                    tempNode = Node(tempTop, "TemperatureSensor", None, ("Index", i), ("Name", tempType),
                                    heading="Temp")

                if args.show_inventory:
                    Node(tempNode, "MaxTemperature", "%.1f" % tempProps.maxTemperature, ("Units", degC),
                         heading="Max", join=".")
                    if tempProps.isCriticalTempSupported:
                        Node(tempNode, "CriticalTempEnabled", bool(tempConfig.enableCritical),
                             header="EnabledCritical", join=".")
                    if tempProps.isThreshold1Supported:
                        t1Node = Node(tempNode, "Threshold1", None, heading="T1", join=".")
                        Node(t1Node, "EnabledLowToHigh", bool(tempConfig.threshold1.enableLowToHigh),
                             join=".")
                        Node(t1Node, "EnabledHighToLow", bool(tempConfig.threshold1.enableHighToLow),
                             join=".")
                        Node(t1Node, "Threshold", "%.1f" % tempConfig.threshold1.threshold,
                             ("Units", degC), join=".")
                    if tempProps.isThreshold2Supported:
                        t2Node = Node(tempNode, "Threshold2", None, heading="T2", join=".")
                        Node(t2Node, "EnabledLowToHigh", bool(tempConfig.threshold2.enableLowToHigh),
                             join=".")
                        Node(t2Node, "EnabledHighToLow", bool(tempConfig.threshold2.enableHighToLow),
                             join=".")
                        Node(t2Node, "Threshold", "%.1f" % tempConfig.threshold2.threshold,
                             ("Units", degC), join=".")

                if args.show_telemetry:
                    node = Node(tempNode, "Current", "?", ("Units", degC), join=".")

                    def tempTelemetry(temp=temp, node=node, degC=degC):
                        try:
                            tempCurrent = zeCall(zesTemperatureGetState(temp))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node.setText("%.1f" % tempCurrent)

                    telemetryClosures.append(tempTelemetry)

        pwrCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPowerDomains(device,pwrCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            powers = zes_pwr_handle_array(pwrCount.value())
            zeCall(zesDeviceEnumPowerDomains(device, pwrCount.cast(), powers.cast()))

        if (args.set_power or args.enable_power or args.disable_power or args.set_burst_power
            or args.enable_burst_power or args.disable_burst_power or args.set_peak_power):
            sustainedLimit = None
            burstLimit = None
            peakLimit = None
            if args.set_power or args.enable_power or args.disable_power:
                sustainedLimit = zes_power_sustained_limit_t()
                if args.set_power:
                    sustainedLimit.enabled = True
                    sustainedLimit.power, remainder = arg.parseMilliwatts(args.set_power)
                    sustainedLimit.interval, remainder = arg.parseMilliseconds(remainder)
                    if remainder:
                        pr.err("WARNING: Extra set-power arguments ignored")
                    if args.enable_power:
                        sustainedLimit.enabled = True
                    if args.disable_power:
                        sustainedLimit.enabled = False
            if args.set_burst_power or args.enable_burst_power or args.disable_burst_power:
                burstLimit = zes_power_burst_limit_t()
                if args.set_burst_power:
                    burstLimit.enabled = True
                    burstLimit.power, remainder = arg.parseMilliwatts(args.set_burst_power)
                    if remainder:
                        pr.err("WARNING: Extra set-burst-power arguments ignored")
                    if args.enable_burst_power:
                        burstLimit.enabled = True
                    if args.disable_burst_power:
                        burstLimit.enabled = False
            if args.set_peak_power:
                peakLimit = zes_power_peak_limit_t()
                peakLimit.powerAC, remainder = arg.parseMilliwatts(args.set_peak_power)
                peakLimit.powerDC, remainder = arg.parseMilliwatts(remainder)
                if remainder:
                    pr.err("WARNING: Extra set-peak-power arguments ignored")
            for i in range(pwrCount.value()):
                pwr = powers[i]
                if sustainedLimit and not args.set_power:
                    zeCall(zesPowerGetLimits(pwr, sustainedLimit, None, None))
                    if args.enable_power:
                        sustainedLimit.enabled = True
                    if args.disable_power:
                        sustainedLimit.enabled = False
                if burstLimit and not args.set_burst_power:
                    zeCall(zesPowerGetLimits(pwr, None, burstLimit, None))
                    if args.enable_burst_power:
                        burstLimit.enabled = True
                    if args.disable_burst_power:
                        burstLimit.enabled = False
                if sustainedLimit:
                    pr("Setting sustained limit to", sustainedLimit.power, "mW,", sustainedLimit.interval,
                       "ms, enabled =", bool(sustainedLimit.enabled))
                if burstLimit:
                    pr("Setting burst limit to", burstLimit.power, "mW, enabled = ", bool(burstLimit.enabled))
                if peakLimit:
                    pr("Setting peak AC, DC limits to", peakLimit.powerAC, "mW,", peakLimit.powerDC, "mW")
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    zeCall(zesPowerSetLimits(pwr, sustainedLimit, burstLimit, peakLimit))

        if args.set_energy_threshold:
            threshold, remainder = arg.parseJoules(args.set_energy_threshold)
            for i in range(pwrCount.value()):
                pwr = powers[i]
                pr("Setting energy threshold to", threshold, "J")
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    zeCall(zesPowerSetEnergyThreshold(pwr, threshold))

        if args.show_power:
            pwrTop = Node(devNode, "PowerDomains", None)

            for i in range(pwrCount.value()):
                pwr = powers[i]
                pwrProps = zes_typed_structure(ZES_STRUCTURE_TYPE_POWER_PROPERTIES)
                zeCall(zesPowerGetProperties(pwr, pwrProps))
                if pwrProps.onSubdevice:
                    pwrNode = Node(pwrTop, "PowerDomain", None, ("Index", i), ("Name", "Subdevice"),
                                   ("SubdeviceId", pwrProps.subdeviceId), heading="Power")
                else:
                    pwrNode = Node(pwrTop, "PowerDomain", None, ("Index", i), ("Name", "Package"),
                                   heading="Power")

                if args.show_inventory:
                    if args.verbose:
                        Node(pwrNode, "CanControl", bool(pwrProps.canControl), join=".")
                        Node(pwrNode, "ThresholdSupported", bool(pwrProps.isEnergyThresholdSupported),
                             join=".")
                        limitNode = Node.RangeNode(pwrNode, "Limit", None, join=".")
                        Node(limitNode, "Min", pwrProps.minLimit, ("Units", "W"), join=".", setFn=units_mW)
                        if pwrProps.defaultLimit >= 0:
                            Node(limitNode, "Default", pwrProps.defaultLimit, ("Units", "W"), join=".",
                                 setFn=units_mW)
                        Node(limitNode, "Max", pwrProps.maxLimit, ("Units", "W"), join=".", setFn=units_mW)

                    sustainedLimit = zes_power_sustained_limit_t()
                    burstLimit = zes_power_burst_limit_t()
                    peakLimit = zes_power_peak_limit_t()
                    zeCall(zesPowerGetLimits(pwr, sustainedLimit, burstLimit, peakLimit))
                    sustainedNode = Node(pwrNode, "SustainedLimit", None, heading="Sustained", join=".")
                    Node(sustainedNode, "Enabled", bool(sustainedLimit.enabled), join=".")
                    Node(sustainedNode, "Power", sustainedLimit.power, ("Units", "W"), join=".", setFn=units_mW)
                    Node(sustainedNode, "Interval", sustainedLimit.interval, ("Units", "s"), join=".", setFn=units_ms)
                    burstNode = Node(pwrNode, "BurstLimit", None, heading="Burst", join=".")
                    Node(burstNode, "Enabled", bool(burstLimit.enabled), join=".")
                    Node(burstNode, "Power", burstLimit.power, ("Units", "W"), join=".", setFn=units_mW)
                    peakNode = Node(pwrNode, "PeakLimit", None, heading="Peak", join=".")
                    Node(peakNode, "Power", peakLimit.powerAC, ("Units", "W"), join=".", setFn=units_mW)
                    if peakLimit.powerDC > 0:
                        Node(peakNode, "PowerOnDC", peakLimit.powerDC, ("Units", "W"), join=".", setFn=units_mW)

                if args.show_telemetry:
                    pwrCounter = zes_power_energy_counter_t()
                    pwrThreshold = zes_energy_threshold_t()
                    zeCall(zesPowerGetEnergyCounter(pwr, pwrCounter))
                    nodes = []
                    nodes.append(Node(pwrNode, "CurrentPower", "?", ("Units", "W"), join=".", setFn=units_mW))
                    nodes.append(Node(pwrNode, "MonitorProcess", "?", join="."))
                    nodes.append(Node(pwrNode, "EnergyThreshold", "?", ("Units", "J"), join=".", setFn=thresh_mJ))

                    def pwrTelemetry(pwr=pwr, pwrCounter=pwrCounter, pwrThreshold=pwrThreshold, node=nodes):
                        oldEnergy, oldTimestamp = pwrCounter.energy, pwrCounter.timestamp
                        zeCall(zesPowerGetEnergyCounter(pwr, pwrCounter))
                        deltaE = pwrCounter.energy - oldEnergy
                        deltaT = pwrCounter.timestamp - oldTimestamp
                        if deltaT > 0:
                            mW = float(deltaE) * 1000 / deltaT
                        else:
                            mW = "?"
                        node[0].setText(mW)
                        try:
                            zeCall(zesPowerGetEnergyThreshold(pwr, pwrThreshold))
                            if pwrThreshold.enable:
                                if pwrThreshold.processId != 0xffffffff:
                                    node[1].setText(pwrThreshold.processId)
                                else:
                                    node[1].setText("Unknown")
                            else:
                                node[1].setText("None")
                            node[2].setText(pwrThreshold.threshold)
                        except NotImplementedError:
                            pass

                    telemetryClosures.append(pwrTelemetry)
                    pollDelayRequired = True

        freqCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFrequencyDomains(device, freqCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            frequencies = zes_freq_handle_array(freqCount.value())
            zeCall(zesDeviceEnumFrequencyDomains(device, freqCount.cast(), frequencies.cast()))

        if args.set_freq or args.reset_freq:
            for i in range(freqCount.value()):
                freqRange = zes_freq_range_t()
                if args.reset_freq:
                    freqRange.min = 0
                    freqRange.max = 0
                if args.set_freq:
                    freqRange.min, remainder = arg.parseMHz(args.set_freq)
                    if remainder:
                        freqRange.max, remainder = arg.parseMHz(remainder)
                        if remainder:
                            pr.err("WARNING: Extra set-freq arguments ignored")
                    else:
                        freqRange.max = freqRange.min
                freq = frequencies[i]
                pr("Setting frequency range to", freqRange.min, "MHz -", freqRange.max, "MHz")
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    zeCall(zesFrequencySetRange(freq, freqRange))

        if args.show_freq:
            freqTop = Node(devNode, "FrequencyDomains", None)

            for i in range(freqCount.value()):
                freq = frequencies[i]
                freqProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_PROPERTIES)
                zeCall(zesFrequencyGetProperties(freq, freqProps))
                freqType = freqTypeString(freqProps.type)
                if freqProps.onSubdevice:
                    freqNode = Node(freqTop, "FrequencyDomain", None, ("Index", i), ("Name", freqType),
                                       ("SubdeviceId", freqProps.subdeviceId), heading="Freq")
                else:
                    freqNode = Node(freqTop, "FrequencyDomain", None, ("Index", i), ("Name", freqType),
                                    heading="Freq")

                if args.show_inventory:
                    if args.verbose:
                        Node(freqNode, "CanControl", bool(freqProps.canControl), join=".")
                        Node(freqNode, "ThrottleEventSupported",
                             bool(freqProps.isThrottleEventSupported), join=".")
                    availFreqsNode = Node.RangeNode(freqNode, "AvailableFrequencies", None, heading="AvailFreqs",
                                                    join=".")
                    if args.verbose:
                        clockCount = uint32_ptr()
                        try:
                            zeCall(zesFrequencyGetAvailableClocks(freq, clockCount.cast(), None))
                        except:
                            Node(availFreqsNode, "Min", freqProps.min, ("Units", "MHz"), join=".", setFn=unitsMHz)
                            Node(availFreqsNode, "Max", freqProps.max, ("Units", "MHz"), join=".", setFn=unitsMHz)
                        else:
                            clockFreqs = double_array(clockCount.value())
                            zeCall(zesFrequencyGetAvailableClocks(freq, clockCount.cast(), clockFreqs.cast()))
                            for clk in range(clockCount.value()):
                                clockFreq = clockFreqs[clk]
                                Node(availFreqsNode, "AvailableFrequency", clockFreq, ("Units", "MHz"), join=".",
                                     rangejoin=", ", setFn=unitsMHz)
                    else:
                        Node(availFreqsNode, "Min", freqProps.min, ("Units", "MHz"), join=".", setFn=unitsMHz)
                        Node(availFreqsNode, "Max", freqProps.max, ("Units", "MHz"), join=".", setFn=unitsMHz)

                    freqRange = zes_freq_range_t()
                    zeCall(zesFrequencyGetRange(freq, freqRange))
                    rangeFreqsNode = Node.RangeNode(freqNode, "FrequencyRange", None, heading="Range", join=".")
                    Node(rangeFreqsNode, "Min", freqRange.min, ("Units", "MHz"), join=".", setFn=unitsMHz)
                    Node(rangeFreqsNode, "Max", freqRange.max, ("Units", "MHz"), join=".", setFn=unitsMHz)

                if args.show_telemetry:
                    freqState = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_STATE)
                    freqThrottle = zes_freq_throttle_time_t()
                    try:
                        zeCall(zesFrequencyGetThrottleTime(freq, freqThrottle))
                    except NotImplementedError:
                        freqThrottle = None
                    except ValueError:
                        logger.reportZeException()
                    nodes = []
                    nodes.append(Node(freqNode, "RequestedFrequency", "?", ("Units", "MHz"),
                                      heading="Requested", join=".", setFn=unitsMHz))
                    nodes.append(Node(freqNode, "ActualFrequency", "?", ("Units", "MHz"),
                                      heading="Actual", join=".", setFn=unitsMHz))
                    nodes.append(Node(freqNode, "ThrottleReasons", "?", join="."))
                    nodes.append(Node(freqNode, "ThrottleTime", "?", ("Units", "%"), join="."))
                    if args.verbose:
                        nodes.append(Node(freqNode, "CurrentVoltage", "?", ("Units", "V"), join=".", setFn=unitsV))
                        nodes.append(Node(freqNode, "Efficient", "?", ("Units", "MHz"), join=".", setFn=unitsMHz))
                        nodes.append(Node(freqNode, "MaximumTDP", "?", ("Units", "MHz"), join=".", setFn=unitsMHz))

                    def freqTelemetry(freq=freq, freqState=freqState, freqThrottle=freqThrottle,
                                      node=nodes, verbose=args.verbose):
                        throttlePercent = "?"
                        if freqThrottle:
                            oldHeld, oldTimestamp = freqThrottle.throttleTime, freqThrottle.timestamp
                            try:
                                zeCall(zesFrequencyGetThrottleTime(freq, freqThrottle))
                            except:
                                logger.reportZeException()
                            else:
                                deltaH = freqThrottle.throttleTime - oldHeld
                                deltaT = freqThrottle.timestamp - oldTimestamp
                                if deltaT > 0:
                                    throttlePercent = "%.0f" % (100.0 * deltaH / deltaT)
                                else:
                                    throttlePercent = "?"
                        zeCall(zesFrequencyGetState(freq, freqState))
                        node[0].setText(freqState.request)
                        node[1].setText(freqState.actual)
                        node[2].setText(throttleReasonsString(freqState.throttleReasons))
                        node[3].setText(throttlePercent)
                        if verbose:
                            node[4].setText(freqState.currentVoltage)
                            node[5].setText(freqState.efficient)
                            node[6].setText(freqState.tdp)

                    telemetryClosures.append(freqTelemetry)
                    pollDelayRequired = True

        # TODO: Use generalized parsing methods that support units

        if args.set_oc_freq:
            idxStr, frqStr = args.set_oc_freq
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                frqMHz = float(frqStr)
            except:
                pr.fail("Usage: --set-oc-freq IDX FREQ")
            pr("Setting oc", i, "frequency target to", frqMHz, "MHz")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    frqMHz = util.saturate(frqMHz, 0.0, ocCaps.maxOcFrequency)
                    zeCall(zesFrequencyOcSetFrequencyTarget(freq, frqMHz))
                except:
                    pr.fail("--set-oc-freq not supported")

        if args.set_oc_volts:
            idxStr, vTargetStr, vOffsetStr = args.set_oc_volts
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                vTarget = float(vTargetStr)
                vOffset = float(vOffsetStr)
            except:
                pr.fail("Usage: --set-oc-volts IDX VOLTAGE_TARGET VOLTAGE_OFFSET")
            pr("Setting oc", i, "voltage target to", vTarget, "V, offset", vOffset, "V")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    vTarget = util.saturate(vTarget, 0.0, ocCaps.maxOcVoltage)
                    vOffset = util.saturate(vOffset, ocCaps.minOcVoltageOffset, ocCaps.maxOcVoltageOffset)
                    zeCall(zesFrequencyOcSetVoltageTarget(freq, vTarget, vOffset))
                except:
                    pr.fail("--set-oc-volts not supported")

        if args.set_oc_off:
            idxStr, = args.set_oc_off
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-off IDX")
            pr("Setting oc", i, "mode to OFF")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_OFF))
                except:
                    pr.fail("--set-oc-off not supported")

        if args.set_oc_override:
            idxStr, = args.set_oc_override
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-override IDX")
            pr("Setting oc", i, "mode to OVERRIDE")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_OVERRIDE))
                except:
                    pr.fail("--set-oc-override not supported")

        if args.set_oc_interpolate:
            idxStr, = args.set_oc_interpolate
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-interpolate IDX")
            pr("Setting oc", i, "mode to INTERPOLATIVE")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_INTERPOLATIVE))
                except:
                    pr.fail("--set-oc-interpolate not supported")

        if args.set_oc_fixed:
            idxStr, = args.set_oc_fixed
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-interpolate IDX")
            pr("Setting oc", i, "mode to FIXED")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isFixedModeSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_FIXED))
                except:
                    pr.fail("--set-oc-interpolate not supported")

        if args.set_oc_max_current:
            idxStr, iccStr = args.set_oc_max_current
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                iccAmps = float(iccStr)
            except:
                pr.fail("Usage: --set-oc-max-current IDX MAX_AMPS")
            pr("Setting oc", i, "maximum current to", iccAmps, "MHz")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isIccMaxSupported
                    zeCall(zesFrequencyOcSetIccMax(freq, iccAmps))
                except:
                    pr.fail("--set-oc-max-current not supported")

        if args.set_oc_max_temp:
            idxStr, tempStr = args.set_oc_max_temp
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                tempC = float(tempStr)
            except:
                pr.fail("Usage: --set-oc-max-temp IDX MAX_DEG_C")
            pr("Setting oc", i, "maximum temperature to", tempC, "MHz")
            if args.dry_run:
                pr(dryRunMessage)
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isTjMaxSupported
                    zeCall(zesFrequencyOcSetTjMax(freq, tempC))
                except:
                    pr.fail("--set-oc-max-temp not supported")

        if args.show_oc:
            ocTop = Node(devNode, "OverclockDomains", None)

            for i in range(freqCount.value()):
                freq = frequencies[i]
                ocNode = None
                try:
                    freqProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_PROPERTIES)
                    zeCall(zesFrequencyGetProperties(freq, freqProps))
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                else:
                    freqType = freqTypeString(freqProps.type)
                    if freqProps.onSubdevice:
                        ocNode = Node(ocTop, "OverclockDomain", None, ("Index", i), ("Name", freqType),
                                           ("SubdeviceId", freqProps.subdeviceId))
                    else:
                        ocNode = Node(ocTop, "OverclockDomain", None, ("Index", i), ("Name", freqType))

                if ocNode and args.show_inventory:
                    try:
                        mode = zeCall(zesFrequencyOcGetMode(freq))
                    except:
                        mode = ZES_OC_MODE_OFF
                    Node(ocNode, "OverclockingMode", ocModeString(mode), join=".")
                    Node(ocNode, "isOcSupported", bool(ocCaps.isOcSupported), join=".")
                    Node(ocNode, "maxFactoryDefaultFrequency", ocCaps.maxFactoryDefaultFrequency, ("Units", "MHz"),
                         join=".", setFn=unitsMHz)
                    Node(ocNode, "maxFactoryDefaultVoltage", ocCaps.maxFactoryDefaultVoltage, ("Units", "V"), join=".",
                         setFn=unitsV)
                    Node(ocNode, "maxOcFrequency", ocCaps.maxOcFrequency, ("Units", "MHz"), join=".", setFn=unitsMHz)
                    Node(ocNode, "minOcVoltageOffset", ocCaps.minOcVoltageOffset, ("Units", "V"), join=".", setFn=unitsV)
                    Node(ocNode, "maxOcVoltageOffset", ocCaps.maxOcVoltageOffset, ("Units", "V"), join=".", setFn=unitsV)
                    Node(ocNode, "maxOcVoltage", ocCaps.maxOcVoltage, ("Units", "V"), join=".", setFn=unitsV)
                    Node(ocNode, "isTjMaxSupported", bool(ocCaps.isTjMaxSupported), join=".")
                    Node(ocNode, "isIccMaxSupported", bool(ocCaps.isIccMaxSupported), join=".")
                    Node(ocNode, "isHighVoltModeCapable", bool(ocCaps.isHighVoltModeCapable), join=".")
                    Node(ocNode, "isHighVoltModeEnabled", bool(ocCaps.isHighVoltModeEnabled), join=".")
                    Node(ocNode, "isExtendedModeSupported", bool(ocCaps.isExtendedModeSupported), join=".")
                    Node(ocNode, "isFixedModeSupported", bool(ocCaps.isFixedModeSupported), join=".")

                    if ocCaps.isOcSupported:
                        try:
                            ocFreq = zeCall(zesFrequencyOcGetFrequencyTarget(freq))
                        except:
                            ocFreq = "?"
                        Node(ocNode, "CurrentOcFrequencyTarget", ocFreq, ("Units", "MHz"), join=".", setFn=unitsMHz)
                        try:
                            vTarget, vOffset = zeCall(zesFrequencyOcGetVoltageTarget(freq))
                        except:
                            vTarget, vOffset = "?", "?"
                        Node(ocNode, "CurrentOcVoltageTarget", vTarget, ("Units", "V"), join=".", setFn=unitsV)
                        Node(ocNode, "CurrentOcVoltageOffset", vOffset, ("Units", "V"), join=".", setFn=unitsV)

                    if ocCaps.isIccMaxSupported:
                        try:
                            iccMax = zeCall(zesFrequencyOcGetIccMax(freq))
                        except:
                            iccMax = "?"
                        Node(ocNode, "OcCurrentLimit", iccMax * 1000, ("Units", "A"), join=".", setFn=units_mA)

                    if ocCaps.isTjMaxSupported:
                        try:
                            tj = zeCall(zesFrequencyOcGetTjMax(freq))
                            tjMax = "%.1f" % tj
                        except:
                            tjMax = "?"
                        Node(ocNode, "OcTemperatureLimit", tjMax, ("Units", degC), join=".")

        engCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumEngineGroups(device, engCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            engs = zes_engine_handle_array(engCount.value())
            zeCall(zesDeviceEnumEngineGroups(device, engCount.cast(), engs.cast()))

        if args.show_util:
            engTop = Node(devNode, "EngineGroups", None)

            for i in range(engCount.value()):
                eng = engs[i]
                engProps = zes_typed_structure(ZES_STRUCTURE_TYPE_ENGINE_PROPERTIES)
                zeCall(zesEngineGetProperties(eng, engProps))
                engType = engTypeString(engProps.type)
                tableType = engTypeTableString(engProps.type)

                if engProps.onSubdevice:
                    engNode = Node(engTop, "EngineGroup", None, ("Index", i), ("Name", engType),
                                   ("SubdeviceId", engProps.subdeviceId), heading=tableType,
                                   headingAttrs=[])
                else:
                    engNode = Node(engTop, "EngineGroup", None, ("Index", i), ("Name", engType),
                                   heading=tableType, headingAttrs=[])

                if args.show_telemetry:
                    utilStats = zes_engine_stats_t()
                    try:
                        zeCall(zesEngineGetActivity(eng, utilStats))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        node = Node(engNode, "Activity", "?", ("Units", "%"), heading="", join="")

                        def utilTelemetry(eng=eng, utilStats=utilStats, node=node):
                            oldActive, oldTimestamp = utilStats.activeTime, utilStats.timestamp
                            zeCall(zesEngineGetActivity(eng, utilStats))
                            deltaA = utilStats.activeTime - oldActive
                            deltaT = utilStats.timestamp - oldTimestamp
                            if deltaT > 0:
                                util = "%.0f" % (100.0 * deltaA / deltaT)
                            else:
                                util = "?"
                            node.setText(util)

                        telemetryClosures.append(utilTelemetry)
                        pollDelayRequired = True

        memCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumMemoryModules(device, memCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            mems = zes_mem_handle_array(memCount.value())
            zeCall(zesDeviceEnumMemoryModules(device, memCount.cast(), mems.cast()))

        if args.show_mem:
            memTop = Node(devNode, "MemoryModules", None)

            for i in range(memCount.value()):
                mem = mems[i]
                memProps = zes_typed_structure(ZES_STRUCTURE_TYPE_MEM_PROPERTIES)
                zeCall(zesMemoryGetProperties(mem, memProps))
                memType = memTypeString(memProps.type)

                if memProps.onSubdevice:
                    memNode = Node(memTop, "MemoryModule", None, ("Index", i), ("Name", memType),
                                      ("SubdeviceId", memProps.subdeviceId), heading="Mem")
                else:
                    memNode = Node(memTop, "MemoryModule", None, ("Index", i), ("Name", memType),
                                   heading="Mem")

                if args.show_inventory:
                    Node(memNode, "Location", memLocString(memProps.location), join=".")
                    Node(memNode, "PhysicalSize", memProps.physicalSize, ("Units", "B"), join=".", setFn=unitsB)
                    Node(memNode, "BusWidth", knownvalue(memProps.busWidth), join=".")
                    Node(memNode, "NumChannels", knownvalue(memProps.numChannels), join=".")

                if args.show_telemetry:
                    memCounter = zes_mem_bandwidth_t()
                    memState = zes_typed_structure(ZES_STRUCTURE_TYPE_MEM_STATE)
                    try:
                        zeCall(zesMemoryGetBandwidth(mem, memCounter))
                        zeCall(zesMemoryGetState(mem, memState))
                    except:
                        pass
                    nodes = []
                    nodes.append(Node(memNode, "Health", "?", join="."))
                    nodes.append(Node(memNode, "Free", "?", ("Units", "B"), join=".", setFn=unitsB))
                    nodes.append(Node(memNode, "Utilized", "?", ("Units", "%"), join="."))
                    nodes.append(Node(memNode, "ReadThroughput", "?", ("Units", "B/s"), join=".", setFn=unitsBps))
                    nodes.append(Node(memNode, "WriteThroughput", "?", ("Units", "B/s"), join=".", setFn=unitsBps))
                    nodes.append(Node(memNode, "Bandwidth", "?", ("Units", "%"), join="."))

                    def memTelemetry(mem=mem, memState=memState, memCounter=memCounter, node=nodes):
                        oldRead, oldWrite = memCounter.readCounter, memCounter.writeCounter
                        oldTimestamp = memCounter.timestamp
                        try:
                            zeCall(zesMemoryGetState(mem, memState))
                        except:
                            pass
                        else:
                            node[0].setText(memHealthString(memState.health))
                            node[1].setText(memState.free)
                            node[2].setText("%.1f" % (100.0 * (memState.size - memState.free) / memState.size))

                        try:
                            zeCall(zesMemoryGetBandwidth(mem, memCounter))
                        except:
                            pass
                        else:
                            deltaR = memCounter.readCounter - oldRead
                            deltaW = memCounter.writeCounter - oldWrite
                            deltaT = memCounter.timestamp - oldTimestamp
                            maxBW = 1.0 * memCounter.maxBandwidth
                            if deltaT > 0:
                                readThroughput = 1e6 * deltaR / deltaT
                                writeThroughput = 1e6 * deltaW / deltaT
                                if maxBW > 0:
                                    memBandwidth = "%.1f" % (1e8 * (deltaR + deltaW) / (maxBW * deltaT))
                                else:
                                    memBandwidth = "?"
                            else:
                                readThroughput = "?"
                                writeThroughput = "?"
                                memBandwidth = "?"

                            node[3].setText(readThroughput)
                            node[4].setText(writeThroughput)
                            node[5].setText(memBandwidth)

                    telemetryClosures.append(memTelemetry)
                    pollDelayRequired = True

        showPci = False
        if args.show_pci:
            pciProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_PROPERTIES)
            try:
                zeCall(zesDevicePciGetProperties(device, pciProps))
            except NotImplementedError:
                pass
            except ValueError:
                logger.reportZeException()
            else:
                showPci = True

        if showPci:
            pciTop = Node(devNode, "PCI", None, heading="PCI")
            if args.show_inventory:
                props = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES)
                zeCall(zesDeviceGetProperties(device, props))
                Node(pciTop, "DeviceId", hex(props.core.deviceId), join=".")
                pciAddr = pciProps.address
                address = "%02x:%02x.%x" % (pciAddr.bus, pciAddr.device, pciAddr.function)
                if pciAddr.domain != 0:
                    address = ("%04x:" % pciAddr.domain) + address
                Node(pciTop, "Address", address, join=".")
                Node(pciTop, "MaxGen", knownvalue(pciProps.maxSpeed.gen), join=".")
                Node(pciTop, "MaxLanes", knownvalue(pciProps.maxSpeed.width), join=".")
                Node(pciTop, "MaxBandwidth", pciProps.maxSpeed.maxBandwidth, ("Units", "B/s"), join=".", setFn=unitsBps)
                Node(pciTop, "HaveBandwidthCounters", pciProps.haveBandwidthCounters, join=".")
                Node(pciTop, "HavePacketCounters", pciProps.havePacketCounters, join=".")
                Node(pciTop, "HaveReplayCounters", pciProps.haveReplayCounters, join=".")

                if args.verbose:
                    barTop = Node(pciTop, "Bars", None)
                    barCount = uint32_ptr()
                    zeCall(zesDevicePciGetBars(device, barCount.cast(), None))
                    bars = zes_typed_array(ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES, barCount.value())
                    zeCall(zesDevicePciGetBars(device, barCount.cast(), bars.cast()))

                    for i in range(barCount.value()):
                        bar = bars[i]
                        barName = barTypeString(bar.type)
                        barNode = Node(barTop, "Bar", None, ("Name", barName))
                        Node(barNode, "Index", bar.index, join=".")
                        Node(barNode, "Base", "0x%016x" % bar.base, join=".")
                        Node(barNode, "Size", "0x%016x" % bar.size, join=".")

            if args.show_telemetry:
                have = { 'bw': pciProps.haveBandwidthCounters, 'pkt' : pciProps.havePacketCounters,
                         'replay' : pciProps.haveReplayCounters }
                pciState = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_STATE)
                try:
                    zeCall(zesDevicePciGetState(device, pciState))
                except:
                    pciState = None
                pciCounter = zes_pci_stats_t()
                try:
                    zeCall(zesDevicePciGetStats(device, pciCounter))
                except:
                    pciCounter = None

                nodes = []
                nodes.append(Node(pciTop, "Status", "?", join="."))
                nodes.append(Node(pciTop, "QualityIssues", "?", join="."))
                nodes.append(Node(pciTop, "StabilityIssues", "?", join="."))
                nodes.append(Node(pciTop, "CurrentGen", "?", join="."))
                nodes.append(Node(pciTop, "CurrentLanes", "?", join="."))
                nodes.append(Node(pciTop, "CurrentBandwidth", "?", ("Units", "B/s"), join=".", setFn=unitsBps))
                if have['bw']:
                    nodes.append(Node(pciTop, "RxThroughput", "?", ("Units", "B/s"), join=".", setFn=unitsBps))
                    nodes.append(Node(pciTop, "TxThroughput", "?", ("Units", "B/s"), join=".", setFn=unitsBps))
                    nodes.append(Node(pciTop, "Utilization", "?", ("Units", "%"), join="."))
                if have['pkt']:
                    nodes.append(Node(pciTop, "PacketRate", "?", join="."))
                    if have['replay']:
                        nodes.append(Node(pciTop, "ReplayRate", "?", ("Units", "%"), join="."))
                elif have['replay']:
                        nodes.append(Node(pciTop, "ReplayRate", "?", join="."))

                def pciTelemetry(device=device, have=have, pciState=pciState, pciCounter=pciCounter,
                                 node=nodes):
                    if pciState:
                        zeCall(zesDevicePciGetState(device, pciState))
                    if pciCounter:
                        oldRx, oldTx = pciCounter.rxCounter, pciCounter.txCounter
                        oldPacket = pciCounter.packetCounter
                        oldReplay = pciCounter.replayCounter
                        oldTimestamp = pciCounter.timestamp
                        zeCall(zesDevicePciGetStats(device, pciCounter))
                        deltaRx = pciCounter.rxCounter - oldRx
                        deltaTx = pciCounter.txCounter - oldTx
                        deltaPacket = pciCounter.packetCounter - oldPacket
                        deltaReplay = pciCounter.replayCounter - oldReplay
                        deltaT = pciCounter.timestamp - oldTimestamp
                        maxBW = 1.0 * pciCounter.speed.maxBandwidth
                    else:
                        deltaT = 0
                    if deltaT > 0:
                        rxThroughput = 1e6 * deltaRx / deltaT
                        txThroughput = 1e6 * deltaTx / deltaT
                        if maxBW > 0:
                            pciUtilization = "%.1f" % (1e8 * (deltaRx + deltaTx) / (maxBW * deltaT))
                        else:
                            pciUtilization = "?"
                    else:
                        rxThroughput = "?"
                        txThroughput = "?"
                        pciUtilization = "?"

                    if have['pkt'] and deltaPacket > 0 and deltaT > 0:
                        packetRate = "%.1f" % (deltaPacket / deltaT)
                        replayRate = "%.1f" % (100.0 * deltaReplay / deltaPacket)
                    elif have['replay'] and deltaReplay > 0 and deltaT > 0:
                        packetRate = "?"
                        replayRate = "%.1f" % (deltaReplay / deltaT)
                    else:
                        packetRate = "?"
                        replayRate = "?"

                    if (pciState and pciCounter and
                            (pciState.speed.gen != pciCounter.speed.gen or
                             pciState.speed.width != pciCounter.speed.width or
                             pciState.speed.maxBandwidth != pciCounter.speed.maxBandwidth)):
                        pr.err("WARNING: speed mismatch between PCI state/stats")

                    if pciState:
                        node[0].setText(pciLinkStatusString(pciState.status))
                        node[1].setText(pciQualityIssuesString(pciState.qualityIssues))
                        node[2].setText(pciStabilityIssuesString(pciState.stabilityIssues))
                    if pciCounter:
                        node[3].setText(knownvalue(pciCounter.speed.gen))
                        node[4].setText(knownvalue(pciCounter.speed.width))
                        node[5].setText(pciCounter.speed.maxBandwidth)
                    i = 6
                    if have['bw']:
                        node[i].setText(rxThroughput)
                        node[i+1].setText(txThroughput)
                        node[i+2].setText(pciUtilization)
                        i += 3
                    if have['pkt']:
                        node[i].setText(packetRate)
                        i += 1
                    if have['replay']:
                        node[i].setText(replayRate)

                telemetryClosures.append(pciTelemetry)
                pollDelayRequired = True

        portCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            ports = zes_fabric_port_handle_array(portCount.value())
            zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), ports.cast()))

        try:
            portNames = []
            for i in range(portCount.value()):
                port = ports[i]
                portProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES)
                zeCall(zesFabricPortGetProperties(port, portProps))
                portName = f"{portProps.portId.attachId}.{portProps.portId.portNumber}"
                assert portName not in portNames
                portNames.append(portName)
        except:
            portNames = list(range(portCount.value()))

        if (args.enable_fabric_ports is not None or args.disable_fabric_ports is not None or
            args.enable_beaconing is not None or args.disable_beaconing is not None):

            if args.enable_fabric_ports is None:
                enable_ports = set()
            elif args.enable_fabric_ports == []:
                enable_ports = set(range(portCount.value()))
            else:
                enable_ports = arg.setPatternMatch(portNames, args.enable_fabric_ports)

            if args.disable_fabric_ports is None:
                disable_ports = set()
            elif args.disable_fabric_ports == []:
                disable_ports = set(range(portCount.value()))
            else:
                disable_ports = arg.setPatternMatch(portNames, args.disable_fabric_ports)

            if args.enable_beaconing is None:
                enable_beacon = set()
            elif args.enable_beaconing == []:
                enable_beacon = set(range(portCount.value()))
            else:
                enable_beacon = arg.setPatternMatch(portNames, args.enable_beaconing)

            if args.disable_beaconing is None:
                disable_beacon = set()
            elif args.disable_beaconing == []:
                disable_beacon = set(range(portCount.value()))
            else:
                disable_beacon = arg.setPatternMatch(portNames, args.disable_beaconing)

            enable_ports = {p for p in enable_ports if p not in disable_ports}
            enable_beacon = {p for p in enable_beacon if p not in disable_beacon}

            if enable_ports:
                pr("Enabling fabric port(s): " + " ".join([portNames[i] for i in sorted(enable_ports)]))
            if disable_ports:
                pr("Disabling fabric port(s): " + " ".join([portNames[i] for i in sorted(disable_ports)]))
            if enable_beacon:
                pr("Enabling beaconing on port(s): " + " ".join([portNames[i] for i in sorted(enable_beacon)]))
            if disable_beacon:
                pr("Disabling beaconing on port(s): " + " ".join([portNames[i] for i in sorted(disable_beacon)]))

            affected_ports = set.union(enable_ports, disable_ports, enable_beacon, disable_beacon)

            if args.dry_run:
                pr(dryRunMessage)
            else:
                for i in range(portCount.value()):
                    if i in affected_ports:
                        port = ports[i]
                        portConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG)
                        zeCall(zesFabricPortGetConfig(port, portConfig))
                        if i in enable_ports:
                            portConfig.enabled = True
                        if i in disable_ports:
                            portConfig.enabled = False
                        if i in enable_beacon:
                            portConfig.beaconing = True
                        if i in disable_beacon:
                            portConfig.beaconing = False
                        zeCall(zesFabricPortSetConfig(port, portConfig))

        if args.show_fabric_ports:
            portTop = Node(devNode, "FabricPorts", None)

            for i in range(portCount.value()):
                port = ports[i]
                portProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES)
                zeCall(zesFabricPortGetProperties(port, portProps))

                portNode = Node(portTop, "FabricPort", None, ("Index", portNames[i]), heading="Port")

                if args.show_inventory:
                    portLinkType = zes_fabric_link_type_t()
                    portConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG)

                    zeCall(zesFabricPortGetLinkType(port, portLinkType))
                    zeCall(zesFabricPortGetConfig(port, portConfig))

                    if portProps.onSubdevice:
                        Node(portNode, "SubdeviceId", portProps.subdeviceId, join=".")
                    Node(portNode, "Model", portProps.model, join=".")
                    Node(portNode, "PhysicalAttachmentType", portLinkType.desc, join=".")
                    Node(portNode, "FabricId", hex(portProps.portId.fabricId), join=".")
                    Node(portNode, "AttachId", portProps.portId.attachId, join=".")
                    Node(portNode, "PortNumber", portProps.portId.portNumber, join=".")
                    Node(portNode, "MaxRxBitrate", portProps.maxRxSpeed.bitRate, ("Units", "bps"), join=".",
                         setFn=units_bps)
                    Node(portNode, "MaxRxWidth", portProps.maxRxSpeed.width, join=".")
                    Node(portNode, "MaxTxBitrate", portProps.maxTxSpeed.bitRate, ("Units", "bps"), join=".",
                         setFn=units_bps)
                    Node(portNode, "MaxTxWidth", portProps.maxTxSpeed.width, join=".")
                    Node(portNode, "Enabled", bool(portConfig.enabled), join=".")
                    Node(portNode, "Beaconing", bool(portConfig.beaconing), join=".")

                if args.show_telemetry:
                    portState = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE)
                    portCounter = zes_fabric_port_throughput_t()
                    zeCall(zesFabricPortGetThroughput(port, portCounter))
                    nodes = []
                    nodes.append(Node(portNode, "Status", "?", join="."))
                    nodes.append(Node(portNode, "QualityIssues", "?", join="."))
                    nodes.append(Node(portNode, "FailureReasons", "?", join="."))
                    nodes.append(Node(portNode, "RemoteFabricId", "?", join="."))
                    nodes.append(Node(portNode, "RemoteAttachId", "?", join="."))
                    nodes.append(Node(portNode, "RemotePortNumber", "?", join="."))
                    nodes.append(Node(portNode, "CurrentRxBitrate", "?", ("Units", "bps"), join=".", setFn=units_bps))
                    nodes.append(Node(portNode, "CurrentRxWidth", "?", join="."))
                    nodes.append(Node(portNode, "CurrentTxBitrate", "?", ("Units", "bps"), join=".", setFn=units_bps))
                    nodes.append(Node(portNode, "CurrentTxWidth", "?", join="."))
                    nodes.append(Node(portNode, "RxThroughput", "?", ("Units", "B/s"), join=".", setFn=unitsBps))
                    nodes.append(Node(portNode, "TxThroughput", "?", ("Units", "B/s"), join=".", setFn=unitsBps))

                    def portTelemetry(port=port, portState=portState, portCounter=portCounter,
                                      node=nodes):
                        oldRx, oldTx = portCounter.rxCounter, portCounter.txCounter
                        oldTimestamp = portCounter.timestamp
                        zeCall(zesFabricPortGetState(port, portState))
                        zeCall(zesFabricPortGetThroughput(port, portCounter))

                        deltaRx = portCounter.rxCounter - oldRx
                        deltaTx = portCounter.txCounter - oldTx
                        deltaT = portCounter.timestamp - oldTimestamp
                        if deltaT > 0:
                            rxThroughput = 1e6 * deltaRx / deltaT
                            txThroughput = 1e6 * deltaTx / deltaT
                        else:
                            rxThroughput = "?"
                            txThroughput = "?"

                        node[0].setText(portStatusString(portState.status))
                        node[1].setText(portQualityIssuesString(portState.qualityIssues))
                        node[2].setText(portFailureReasonsString(portState.failureReasons))
                        node[3].setText(portState.remotePortId.fabricId)
                        node[4].setText(portState.remotePortId.attachId)
                        node[5].setText(portState.remotePortId.portNumber)
                        node[6].setText(portState.rxSpeed.bitRate)
                        node[7].setText(portState.rxSpeed.width)
                        node[8].setText(portState.txSpeed.bitRate)
                        node[9].setText(portState.txSpeed.width)
                        node[10].setText(rxThroughput)
                        node[11].setText(txThroughput)

                    telemetryClosures.append(portTelemetry)
                    pollDelayRequired = True

        edomCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumRasErrorSets(device, edomCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            edoms = zes_ras_handle_array(edomCount.value())
            zeCall(zesDeviceEnumRasErrorSets(device, edomCount.cast(), edoms.cast()))

        if args.set_error_thresholds:
            i,thresholds = args.set_error_thresholds[0], args.set_error_thresholds[1:]
            try:
                assert 0 <= i < edomCount.value()
                assert 0 < len(thresholds) <= ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1
            except:
                pr.fail("ERROR: must specify a valid error domain index and 1 to",
                        ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1,"thresholds")
            else:
                pr("Setting error domain", i, "thresholds to", thresholds)
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    try:
                        ras = edoms[i]
                        rasConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_CONFIG)
                        if len(thresholds) < ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1:
                            zeCall(zesRasGetConfig(ras, rasConfig))
                        else:
                            rasConfig.totalThreshold = thresholds.pop()
                        for t in range(len(thresholds)):
                            ras_category_set(rasConfig.detailedThresholds, t, thresholds[t])
                        zeCall(zesRasSetConfig(ras, rasConfig))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_errors:
            rasTop = Node(devNode, "ErrorDomains", None)

            for i in range(edomCount.value()):
                ras = edoms[i]
                rasProps = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_PROPERTIES)
                try:
                    zeCall(zesRasGetProperties(ras, rasProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    logger.reportZeException()
                    continue
                rasType = rasTypeString(rasProps.type)

                if rasProps.onSubdevice:
                    rasNode = Node(rasTop, "ErrorDomain", None, ("Index", i), ("Name", rasType),
                                   ("SubdeviceId", rasProps.subdeviceId), heading="Err")
                else:
                    rasNode = Node(rasTop, "ErrorDomain", None, ("Index", i), ("Name", rasType),
                                   heading="Err")

                if args.show_inventory:
                    try:
                        rasConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_CONFIG)
                        zeCall(zesRasGetConfig(ras, rasConfig))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        thresholdNode = Node(rasNode, "Thresholds", None, heading="Threshold", join=".")
                        thresholds = rasConfig.detailedThresholds

                        Node(thresholdNode, "Resets", ras_category(thresholds, ZES_RAS_ERROR_CAT_RESET),
                             join=".")
                        Node(thresholdNode, "ProgrammingErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_PROGRAMMING_ERRORS), join=".")
                        Node(thresholdNode, "DriverErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_DRIVER_ERRORS), join=".")
                        Node(thresholdNode, "ComputeErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_COMPUTE_ERRORS), join=".")
                        Node(thresholdNode, "NonComputeErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_NON_COMPUTE_ERRORS), join=".")
                        Node(thresholdNode, "CacheErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_CACHE_ERRORS), join=".")
                        Node(thresholdNode, "DisplayErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_DISPLAY_ERRORS), join=".")
                        Node(thresholdNode, "TotalErrors", rasConfig.totalThreshold, join=".")

                if args.show_telemetry:
                    rasState = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_STATE)

                    nodes = []
                    nodes.append(Node(rasNode, "Resets", "?", join="."))
                    nodes.append(Node(rasNode, "ProgrammingErrors", "?", join="."))
                    nodes.append(Node(rasNode, "DriverErrors", "?", join="."))
                    nodes.append(Node(rasNode, "ComputeErrors", "?", join="."))
                    nodes.append(Node(rasNode, "NonComputeErrors", "?", join="."))
                    nodes.append(Node(rasNode, "CacheErrors", "?", join="."))
                    nodes.append(Node(rasNode, "DisplayErrors", "?", join="."))

                    def rasTelemetry(ras=ras, node=nodes, rasState=rasState):
                        try:
                            zeCall(zesRasGetState(ras, args.clear_errors, rasState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_RESET))
                            node[1].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_PROGRAMMING_ERRORS))
                            node[2].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_DRIVER_ERRORS))
                            node[3].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_COMPUTE_ERRORS))
                            node[4].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_NON_COMPUTE_ERRORS))
                            node[5].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_CACHE_ERRORS))
                            node[6].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_DISPLAY_ERRORS))

                    telemetryClosures.append(rasTelemetry)

        if args.clear_errors and not args.show_telemetry:
            for i in range(edomCount.value()):
                ras = edoms[i]
                try:
                    zeCall(zesRasGetState(ras, True, None))
                except ValueError as err:
                    pr.err("workaround... ERROR: zesRasGetState returned error, ignoring...", err)

        stbyCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumStandbyDomains(device, stbyCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            stbys = zes_standby_handle_array(stbyCount.value())
            zeCall(zesDeviceEnumStandbyDomains(device, stbyCount.cast(), stbys.cast()))

        if args.set_standby is not None:
            for i in range(stbyCount.value()):
                stby = stbys[i]
                if args.set_standby.lower() in ["enabled", "en", "1", "y", "yes", "t", "true"]:
                    pr("Enabling standby promotion")
                    if args.dry_run:
                        pr(dryRunMessage)
                    else:
                        zeCall(zesStandbySetMode(stby, ZES_STANDBY_PROMO_MODE_DEFAULT))
                elif args.set_standby.lower() in ["disabled", "dis", "0", "n", "no", "f", "false"]:
                    pr("Disabling standby promotion")
                    if args.dry_run:
                        pr(dryRunMessage)
                    else:
                        zeCall(zesStandbySetMode(stby, ZES_STANDBY_PROMO_MODE_NEVER))
                else:
                    pr.err("WARNING: ignoring unrecognized set-standby value", args.set_standby)

        if args.show_standby:
            stbyTop = Node(devNode, "StandbyDomains", None)

            for i in range(stbyCount.value()):
                stby = stbys[i]
                stbyProps = zes_typed_structure(ZES_STRUCTURE_TYPE_STANDBY_PROPERTIES)
                zeCall(zesStandbyGetProperties(stby, stbyProps))
                stbyType = stbyTypeString(stbyProps.type)

                if stbyProps.onSubdevice:
                    stbyNode = Node(stbyTop, "StandbyDomain", None, ("Index", i), ("Name", stbyType),
                                    ("SubdeviceId", stbyProps.subdeviceId), heading="Standby")
                else:
                    stbyNode = Node(stbyTop, "StandbyDomain", None, ("Index", i), ("Name", stbyType),
                                    heading="Standby")

                if args.show_inventory:
                    modeString = stbyPromoModeString(zeCall(zesStandbyGetMode(stby)))
                    Node(stbyNode, "SleepStateMode", modeString, join=".")

        procCount = uint32_ptr()
        try:
            zeCall(zesDeviceProcessesGetState(device, procCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            procs = zes_typed_array(ZES_STRUCTURE_TYPE_PROCESS_STATE, procCount.value())
            zeCall(zesDeviceProcessesGetState(device, procCount.cast(), procs.cast()))

        if args.show_processes:
            procTop = Node(devNode, "ProcessUsages", None)

            for i in range(procCount.value()):
                proc = procs[i]
                procNode = Node(procTop, "ProcessUsage", None, ("Id", proc.processId))

                if args.show_telemetry:
                    Node(procNode, "MemUsage", "0x%08x" % proc.memSize, join=".")
                    engineNames = enginesUsedString(proc.engines)
                    Node(procNode, "EngineUsage", engineNames, join=".")

        schedCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumSchedulers(device, schedCount.cast(), None))
        except:
            pass
        else:
            scheds = zes_sched_handle_array(schedCount.value())
            zeCall(zesDeviceEnumSchedulers(device, schedCount.cast(), scheds.cast()))

        if args.set_scheduler:
            idx, schedulerArgs = args.set_scheduler[0], args.set_scheduler[1:]
            try:
                i = int(idx)
                assert 0 <= i < schedCount.value()
                sched = scheds[i]
                mode, remainder = arg.parseSchedulerMode(schedulerArgs)
                needsReboot = False
                if mode == ZES_SCHED_MODE_TIMEOUT:
                    schedCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES)
                    watchdogTimeout, remainder = arg.parseMicroseconds(remainder)
                    if watchdogTimeout == 0:
                        zeCall(zesSchedulerGetTimeoutModeProperties(sched, False, schedCfg))
                    else:
                        schedCfg.watchdogTimeout = watchdogTimeout
                    pr("Setting scheduling mode to timeout")
                    if args.dry_run:
                        pr(dryRunMessage)
                    else:
                        needsReboot = zeCall(zesSchedulerSetTimeoutMode(sched, schedCfg))
                elif mode == ZES_SCHED_MODE_TIMESLICE:
                    schedCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)
                    interval, remainder = arg.parseMicroseconds(remainder)
                    yieldTimeout, remainder = arg.parseMicroseconds(remainder)
                    if interval == 0 or yieldTimeout == 0:
                        zeCall(zesSchedulerGetTimesliceModeProperties(sched, False, schedCfg))
                    if interval != 0:
                        schedCfg.interval = interval
                    if yieldTimeout != 0:
                        schedCfg.yieldTimeout = yieldTimeout
                    pr("Setting scheduling mode to timeslice")
                    if args.dry_run:
                        pr(dryRunMessage)
                    else:
                        needsReboot = zeCall(zesSchedulerSetTimesliceMode(sched, schedCfg))
                elif mode == ZES_SCHED_MODE_EXCLUSIVE:
                    pr("Setting scheduling mode to exclusive")
                    if args.dry_run:
                        pr(dryRunMessage)
                    else:
                        needsReboot = zeCall(zesSchedulerSetExclusiveMode(sched))
                elif mode == ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG:
                    pr("Setting scheduling mode to compute unit debug")
                    if args.dry_run:
                        pr(dryRunMessage)
                    else:
                        needsReboot = zeCall(zesSchedulerSetComputeUnitDebugMode(sched))
                if remainder:
                    pr.err("WARNING: Extra set-scheduler arguments ignored")
                    pr.err(remainder)
                if needsReboot:
                    pr.err("NOTE: reboot required")
            except:
                pr.fail("Must specify a valid scheduler index and supported mode")

        if args.show_scheduler:
            schedTop = Node(devNode, "Schedulers", None)
            for i in range(schedCount.value()):
                sched = scheds[i]
                schedProps = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_PROPERTIES)
                try:
                    zeCall(zesSchedulerGetProperties(sched, schedProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    logger.reportZeException()
                    continue

                if schedProps.onSubdevice:
                    schedNode = Node(schedTop, "Scheduler", None, ("Index", i),
                                     ("SubdeviceId", schedProps.subdeviceId))
                else:
                    schedNode = Node(schedTop, "Scheduler", None, ("Index", i))

                if args.show_inventory:
                    Node(schedNode, "CanControl", bool(schedProps.canControl), join=".")
                    Node(schedNode, "Engines", enginesUsedString(schedProps.engines), join=".")
                    Node(schedNode, "SupportedModes", schedSupportedModesString(schedProps.supportedModes),
                         join=".")
                    if args.verbose:
                        timeoutCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES)
                        zeCall(zesSchedulerGetTimeoutModeProperties(sched, True, timeoutCfg))
                        if timeoutCfg.watchdogTimeout == ZES_SCHED_WATCHDOG_DISABLE:
                            Node(schedNode, "DefaultTimeout", "Disabled", join=".")
                        else:
                            Node(schedNode, "DefaultTimeout", timeoutCfg.watchdogTimeout, ("Units", "ms"), join=".",
                                 setFn=units_us)
                        tsCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)
                        zeCall(zesSchedulerGetTimesliceModeProperties(sched, True, tsCfg))
                        Node(schedNode, "DefaultInterval", tsCfg.interval, ("Units", "ms"), join=".", setFn=units_us)
                        Node(schedNode, "DefaultYieldTimeout", tsCfg.yieldTimeout, ("Units", "ms"), join=".",
                             setFn=units_us)

                if args.show_telemetry:
                    cfgs = [zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES),
                            zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)]
                    nodes = []
                    nodes.append(Node(schedNode, "Mode", "?", join="."))
                    nodes.append(Node(schedNode, "Timeout", "?", ("Units", "ms"), join=".", setFn=units_us))
                    nodes.append(Node(schedNode, "Interval", "?", ("Units", "ms"), join=".", setFn=units_us))
                    nodes.append(Node(schedNode, "YieldTimeout", "?", ("Units", "ms"), join=".", setFn=units_us))

                    def schedTelemetry(sched=sched, node=nodes, cfg=cfgs):
                        try:
                            mode = zeCall(zesSchedulerGetCurrentMode(sched))
                            if mode == ZES_SCHED_MODE_TIMEOUT:
                                zeCall(zesSchedulerGetTimeoutModeProperties(sched, False, cfg[0]))
                            elif mode == ZES_SCHED_MODE_TIMESLICE:
                                zeCall(zesSchedulerGetTimesliceModeProperties(sched, False, cfg[1]))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(schedModeString(mode))
                            if mode == ZES_SCHED_MODE_TIMEOUT:
                                if cfg[0].watchdogTimeout == ZES_SCHED_WATCHDOG_DISABLE:
                                    node[1].setText("Disabled")
                                else:
                                    node[1].setText(cfg[0].watchdogTimeout)
                            else:
                                node[1].setText("?")
                            if mode == ZES_SCHED_MODE_TIMESLICE:
                                node[2].setText(cfg[1].interval)
                                node[3].setText(cfg[1].yieldTimeout)
                            else:
                                node[2].setText("?")
                                node[3].setText("?")

                    telemetryClosures.append(schedTelemetry)

        diagCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumDiagnosticTestSuites(device, diagCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            diags = zes_diag_handle_array(diagCount.value())
            zeCall(zesDeviceEnumDiagnosticTestSuites(device, diagCount.cast(), diags.cast()))

        if args.show_diag:
            diagTop = Node(devNode, "TestSuites", None)

            for i in range(diagCount.value()):
                diag = diags[i]
                diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
                zeCall(zesDiagnosticsGetProperties(diag, diagProps))
                if diagProps.onSubdevice:
                    diagNode = Node(diagTop, "TestSuite", None, ("Index", i), ("Name", diagProps.name),
                                    ("SubdeviceId", diagProps.subdeviceId))
                else:
                    diagNode = Node(diagTop, "TestSuite", None, ("Index", i), ("Name", diagProps.name))

                if args.show_inventory and diagProps.haveTests:
                    testCount = uint32_ptr()
                    try:
                        zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), None))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        tests = zes_diag_test_array(testCount.value())
                        zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), tests.cast()))

                    for t in range(testCount.value()):
                        test = tests[t]
                        Node(diagNode, "Test", test.name, ("Id", test.index), join=".")

        fanCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFans(device, fanCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            fans = zes_fan_handle_array(fanCount.value())
            zeCall(zesDeviceEnumFans(device, fanCount.cast(), fans.cast()))

        if args.set_fan_speed_default:
            i, = args.set_fan_speed_default
            if 0 <= i < fanCount.value():
                try:
                    fan = fans[i]
                    zeCall(zesFanSetDefaultMode(fan))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index")

        if args.set_fan_speed_rpm:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxRPM = fanProps.maxRPM
            except:
                maxRPM = 1000000
            i, rpm = args.set_fan_speed_rpm
            if 0 <= i < fanCount.value() and 0 <= rpm <= maxRPM:
                try:
                    fan = fans[i]
                    speed = zes_fan_speed_t()
                    speed.speed = rpm
                    speed.units = ZES_FAN_SPEED_UNITS_RPM
                    zeCall(zesFanSetFixedSpeedMode(fan, speed))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index")

        if args.set_fan_speed_percent:
            i, pct = args.set_fan_speed_percent
            if 0 <= i < fanCount.value() and 0 <= pct <= 100:
                try:
                    fan = fans[i]
                    speed = zes_fan_speed_t()
                    speed.speed = pct
                    speed.units = ZES_FAN_SPEED_UNITS_PERCENT
                    zeCall(zesFanSetFixedSpeedMode(fan, speed))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and fan percent")

        if args.set_fan_speed_table_rpm:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxRPM = fanProps.maxRPM
                maxPoints = fanProps.maxPoints
            except:
                maxRPM = 1000000
                maxPoints = ZES_FAN_TEMP_SPEED_PAIR_COUNT
            i = args.set_fan_speed_table_rpm[0]
            table = []
            try:
                assert 0 <= i < fanCount.value()
                assert len(args.set_fan_speed_table_rpm) % 2
                temp = -274
                for s in range(1, len(args.set_fan_speed_table_rpm), 2):
                    entry = (args.set_fan_speed_table_rpm[s], args.set_fan_speed_table_rpm[s+1])
                    assert entry[0] > temp
                    temp = entry[0]
                    assert 0 <= entry[1] <= maxRPM
                    table.append(entry)
                assert len(table) <= ZES_FAN_TEMP_SPEED_PAIR_COUNT
                assert len(table) <= maxPoints
            except:
                table = []

            if table:
                try:
                    fan = fans[i]
                    fanTable = zes_fan_speed_table_t()
                    tempSpeed = zes_fan_temp_speed_array(len(table))
                    for t,entry in util.indexed(table):
                        item = tempSpeed[t]
                        item.temperature = entry[0]
                        item.speed.speed = entry[1]
                        item.speed.units = ZES_FAN_SPEED_UNITS_RPM
                        tempSpeed[t] = item
                    fan_speed_table_set(fanTable, len(table), tempSpeed.cast())
                    zeCall(zesFanSetSpeedTableMode(fan, fanTable))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and rpm table")

        if args.set_fan_speed_table_percent:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxPoints = fanProps.maxPoints
            except:
                maxPoints = ZES_FAN_TEMP_SPEED_PAIR_COUNT
            i = args.set_fan_speed_table_percent[0]
            table = []
            try:
                assert 0 <= i < fanCount.value()
                assert len(args.set_fan_speed_table_percent) % 2
                temp = -274
                for s in range(1, len(args.set_fan_speed_table_percent), 2):
                    entry = (args.set_fan_speed_table_percent[s], args.set_fan_speed_table_percent[s+1])
                    assert entry[0] > temp
                    temp = entry[0]
                    assert 0 <= entry[1] <= 100
                    table.append(entry)
                assert len(table) <= ZES_FAN_TEMP_SPEED_PAIR_COUNT
                assert len(table) <= maxPoints
            except:
                table = []

            if table:
                try:
                    fan = fans[i]
                    fanTable = zes_fan_speed_table_t()
                    tempSpeed = zes_fan_temp_speed_array(len(table))
                    for t,entry in util.indexed(table):
                        item = tempSpeed[t]
                        item.temperature = entry[0]
                        item.speed.speed = entry[1]
                        item.speed.units = ZES_FAN_SPEED_UNITS_PERCENT
                        tempSpeed[t] = item
                    fan_speed_table_set(fanTable, len(table), tempSpeed.cast())
                    zeCall(zesFanSetSpeedTableMode(fan, fanTable))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and fan percent table")

        if args.show_fans:
            fanTop = Node(devNode, "Fans", None)

            for i in range(fanCount.value()):
                fan = fans[i]

                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))

                if fanProps.onSubdevice:
                    fanNode = Node(fanTop, "Fan", None, ("Index", i),
                                   ("SubdeviceId", fanProps.subdeviceId))
                else:
                    fanNode = Node(fanTop, "Fan", None, ("Index", i))

                fanConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_CONFIG)
                zeCall(zesFanGetConfig(fan, fanConfig))

                if args.show_inventory:
                    Node(fanNode, "CanControl", bool(fanProps.canControl), join=".")
                    Node(fanNode, "SupportedModes", supportedFanModesString(fanProps.supportedModes),
                         join=".")
                    Node(fanNode, "SupportedUnits", supportedFanUnitsString(fanProps.supportedUnits),
                         join=".")
                    Node(fanNode, "MaxRPM", knownvalue(fanProps.maxRPM), join=".")
                    Node(fanNode, "MaxPoints", knownvalue(fanProps.maxPoints, "Unsupported"), join=".")
                    Node(fanNode, "Mode", fanModeString(fanConfig.mode), join=".")
                    if fanConfig.mode == ZES_FAN_SPEED_MODE_FIXED:
                        Node(fanNode, "FixedSpeed", fanConfig.speedFixed.speed,
                             ("Units", fanUnitString(fanConfig.speedFixed.units)), join=".")
                    # Current API does not support this yet:
                    # if fanConfig.mode == ZES_FAN_SPEED_MODE_TABLE:
                        # tableSize = fanConfig.speedTable.numPoints
                        # tempSpeed = zes_fan_temp_speed_array(tableSize)
                        # fan_config_speed_table_get(fanConfig, tableSize, tempSpeed.cast())
                        # numPoints = min(tableSize, ZES_FAN_TEMP_SPEED_PAIR_COUNT)
                        # for s in range(numPoints):
                        #     fanTemp = Node(fanNode, "TempSpeed", None, join=".")
                        #     item = tempSpeed[s]
                        #     Node(fanTemp, "Temp", item.temperature, ("Units", degC), join=".")
                        #     Node(fanTemp, "Speed", item.speed.speed, ("Index", s),
                        #          ("Units", fanUnitString(item.speed.units)), join=".")

                if args.show_telemetry:
                    nodes = []
                    nodes.append(Node(fanNode, "Speed", "?",
                                 ("Units", fanUnitString(ZES_FAN_SPEED_UNITS_RPM)), join="."))
                    nodes.append(Node(fanNode, "Speed", "?",
                                 ("Units", fanUnitString(ZES_FAN_SPEED_UNITS_PERCENT)), join="."))

                    def fanTelemetry(fan=fan, node=nodes):
                        try:
                            rpm = zeCall(zesFanGetState(fan, ZES_FAN_SPEED_UNITS_RPM))
                            pct = zeCall(zesFanGetState(fan, ZES_FAN_SPEED_UNITS_PERCENT))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(rpm)
                            node[1].setText(pct)

                    telemetryClosures.append(fanTelemetry)

        fwCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFirmwares(device, fwCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            fws = zes_firmware_handle_array(fwCount.value())
            zeCall(zesDeviceEnumFirmwares(device, fwCount.cast(), fws.cast()))

        if args.flash_firmware:
            filename, = args.flash_firmware
            names = ["%s [%s]" % (d,output.uuid(u)) for d,u in zip(deviceIDs,deviceUUIDs)]
            pr("Requesting flash of", filename, "to the following devices:")
            pr(" " + "\n ".join(names))

            if not args.yes:
                answer = input("Do you really want to flash? ")
                args.yes = answer.lower() in ("y", "yes")

            if args.yes:
                pr("Preparing to flash devices")
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    zeCall(zesDeviceReset(devices[0], args.force))
                    size = uint32_ptr()
                    with open(filename, "rb") as f:
                        image = f.read()
                    for i in range(fwCount.value()):
                        fw = fws[i]
                        pr("Flashing device", names[i])
                        # zeCall(zesFirmwareFlash(fw, image, len(image)))
                        zeCall(zesFirmwareFlashData(fw, image))
            else:
                pr("NOT flashing device(s)")

            sys.exit(0)

        if args.show_firmware:
            fwTop = Node(devNode, "Firmwares", None)

            for i in range(fwCount.value()):
                fw = fws[i]

                fwProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FIRMWARE_PROPERTIES)
                zeCall(zesFirmwareGetProperties(fw, fwProps))

                if fwProps.onSubdevice:
                    fwNode = Node(fwTop, "Firmware", None, ("Index", i),
                                   ("SubdeviceId", fwProps.subdeviceId))
                else:
                    fwNode = Node(fwTop, "Firmware", None, ("Index", i))

                if args.show_inventory:
                    Node(fwNode, "CanControl", bool(fwProps.canControl), join=".")
                    Node(fwNode, "Name", fwProps.name, join=".")
                    Node(fwNode, "Version", fwProps.version, join=".")

        ledCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumLeds(device, ledCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            leds = zes_led_handle_array(ledCount.value())
            zeCall(zesDeviceEnumLeds(device, ledCount.cast(), leds.cast()))

        if args.enable_led:
            i, = args.enable_led
            if 0 <= i < ledCount.value():
                pr("Enabling led", i)
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetState(led, True))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid led index")

        if args.disable_led:
            i, = args.disable_led
            if 0 <= i < ledCount.value():
                pr("Disabling led", i)
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetState(led, False))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid led index")

        if args.set_led_color:
            idx,colors = args.set_led_color[0], args.set_led_color[1:]
            if len(colors) == 1:
                ledColors = {
                    "white" : (1.0, 1.0, 1.0),
                    "yellow" : (1.0, 1.0, 0.0),
                    "magenta" : (1.0, 0.0, 1.0),
                    "red" : (1.0, 0.0, 0.0),
                    "gray" : (0.5, 0.5, 0.5),
                    "grey" : (0.5, 0.5, 0.5),
                    "cyan" : (0.0, 1.0, 1.0),
                    "green" : (0.0, 1.0, 0.0),
                    "blue" : (0.0, 0.0, 1.0),
                    "black" : (0.0, 0.0, 0.0) }
                colorStr, = colors
                colors = ledColors.get(colorStr.lower())
            try:
                i = int(idx)
                assert 0 <= i < ledCount.value()
                redStr, greenStr, blueStr = colors
                red, green, blue = float(redStr), float(greenStr), float(blueStr)
                assert 0.0 <= red <= 1.0
                assert 0.0 <= green <= 1.0
                assert 0.0 <= blue <= 1.0
            except:
                pr.fail("ERROR: must specify a valid led index and color name or triplet 0-1 0-1 0-1")
            else:
                color = zes_led_color_t()
                color.red, color.green, color.blue = red, green, blue
                pr("Setting led", i, "color to", colorString(color))
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetColor(led, color))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_leds:
            ledTop = Node(devNode, "Leds", None)

            for i in range(ledCount.value()):
                led = leds[i]

                ledProps = zes_typed_structure(ZES_STRUCTURE_TYPE_LED_PROPERTIES)
                zeCall(zesLedGetProperties(led, ledProps))

                if ledProps.onSubdevice:
                    ledNode = Node(ledTop, "Led", None, ("Index", i),
                                   ("SubdeviceId", ledProps.subdeviceId))
                else:
                    ledNode = Node(ledTop, "Led", None, ("Index", i))

                if args.show_inventory:
                    Node(ledNode, "CanControl", bool(ledProps.canControl), join=".")
                    Node(ledNode, "HaveRGB", bool(ledProps.haveRGB), join=".")

                if args.show_telemetry:
                    ledState = zes_typed_structure(ZES_STRUCTURE_TYPE_LED_STATE)
                    nodes = []
                    nodes.append(Node(ledNode, "State", "?", join="."))
                    if ledProps.haveRGB:
                        nodes.append(Node(ledNode, "Color", "?", join="."))

                    def ledTelemetry(led=led, node=nodes, ledState=ledState):
                        try:
                            zeCall(zesLedGetState(led, ledState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(onOffString(ledState.isOn))
                            if len(node) > 1:
                                node[1].setText(colorString(ledState.color))

                    telemetryClosures.append(ledTelemetry)

        perfCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPerformanceFactorDomains(device, perfCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            perfs = zes_perf_handle_array(perfCount.value())
            zeCall(zesDeviceEnumPerformanceFactorDomains(device, perfCount.cast(), perfs.cast()))

        if args.set_perf:
            idx,valStr = args.set_perf
            try:
                i = int(idx)
                assert 0 <= i < perfCount.value()
                val = float(valStr)
                assert 0.0 <= val <= 100.0
            except:
                pr.fail("ERROR: must specify a valid performance factor index and value (0 - 100)")
            else:
                pr("Setting performance factor", i, "to", val)
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    try:
                        perf = perfs[i]
                        zeCall(zesPerformanceFactorSetConfig(perf, val))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_perf:
            perfTop = Node(devNode, "PerformanceFactors", None)

            for i in range(perfCount.value()):
                perf = perfs[i]

                perfProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PERF_PROPERTIES)
                zeCall(zesPerformanceFactorGetProperties(perf, perfProps))

                if perfProps.onSubdevice:
                    perfNode = Node(perfTop, "PerformanceFactor", None, ("Index", i),
                                   ("SubdeviceId", perfProps.subdeviceId))
                else:
                    perfNode = Node(perfTop, "PerformanceFactor", None, ("Index", i))

                if args.show_inventory:
                    Node(perfNode, "Engines", enginesUsedString(perfProps.engines), join=".")

                if args.show_telemetry:
                    nodes = []
                    nodes.append(Node(perfNode, "Value", "?", ("Units", "%"), join="."))

                    def perfTelemetry(perf=perf, node=nodes):
                        try:
                            val = zeCall(zesPerformanceFactorGetConfig(perf))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(val)

                    telemetryClosures.append(perfTelemetry)

        psuCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPsus(device, psuCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            psus = zes_psu_handle_array(psuCount.value())
            zeCall(zesDeviceEnumPsus(device, psuCount.cast(), psus.cast()))

        if args.set_perf:
            idx,valStr = args.set_perf
            try:
                i = int(idx)
                assert 0 <= i < perfCount.value()
                val = float(valStr)
                assert 0.0 <= val <= 100.0
            except:
                pr.fail("ERROR: must specify a valid performance factor index and value (0 - 100)")
            else:
                pr("Setting performance factor", i, "to", val)
                if args.dry_run:
                    pr(dryRunMessage)
                else:
                    try:
                        perf = perfs[i]
                        zeCall(zesPerformanceFactorSetConfig(perf, val))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_psu:
            psuTop = Node(devNode, "PowerSupplies", None)

            for i in range(psuCount.value()):
                psu = psus[i]

                psuProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PSU_PROPERTIES)
                zeCall(zesPsuGetProperties(psu, psuProps))

                if psuProps.onSubdevice:
                    psuNode = Node(psuTop, "PowerSupply", None, ("Index", i),
                                   ("SubdeviceId", psuProps.subdeviceId))
                else:
                    psuNode = Node(psuTop, "PowerSupply", None, ("Index", i))

                if args.show_inventory:
                    Node(psuNode, "HaveFan", bool(psuProps.haveFan), join=".")
                    Node(psuNode, "CurrentLimit", psuProps.ampLimit, ('Units', 'A'), join=".", setFn=units_mA)

                if args.show_telemetry:
                    psuState = zes_typed_structure(ZES_STRUCTURE_TYPE_PSU_STATE)
                    nodes = []
                    nodes.append(Node(psuNode, "VoltageStatus", "?", join="."))
                    nodes.append(Node(psuNode, "FanFailed", "?", join="."))
                    nodes.append(Node(psuNode, "Temperature", "?", ('Units', degC), join="."))
                    nodes.append(Node(psuNode, "Current", "?", ('Units', 'A'), join=".", setFn=units_mA))

                    def psuTelemetry(psu=psu, node=nodes, psuState=psuState):
                        try:
                            zeCall(zesPsuGetState(psu, psuState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(psuVoltageStatusString(psuState.voltStatus))
                            node[1].setText(bool(psuState.fanFailed))
                            node[2].setText(fmtknown(psuState.temperature))
                            node[3].setText(psuState.current)

                    telemetryClosures.append(psuTelemetry)

    if args.dry_run:
        if generatingDeviceReport:
            pr("Device Report", dryRunMessage)
        sys.exit(0)

    if pollDelayRequired:
        delayed = delay(state.pollInterval)
        if not delayed:
            sys.exit(0)

    for closure in telemetryClosures:
        closure()

    topNode.outputStart()

    currentIteration = 1
    topNode.outputTree()

    while currentIteration < state.maxIterations:
        delayed = delay(state.pollInterval)
        if not delayed:
            break

        for closure in telemetryClosures:
            closure()

        currentIteration += 1
        topNode.outputTree()

    topNode.outputFinish()

if __name__ == "__main__":
    main()
